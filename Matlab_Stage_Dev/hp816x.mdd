<?xml version="1.0" encoding="utf-8"?>
<MATLABInstrumentDriver>
   <FileVersion>2.42</FileVersion>
   <DriverName>hp816x</DriverName>
   <DriverType>MATLAB VXIplug&amp;play</DriverType>
   <InstrumentType>VXIPnPInstrument</InstrumentType>
   <InstrumentManufacturer>Hewlett-Packard Company</InstrumentManufacturer>
   <InstrumentModel>hp816x</InstrumentModel>
   <InstrumentVersion>1.0</InstrumentVersion>
   <Identify/>
   <Reset/>
   <Selftest/>
   <Error/>
   <CreateInitCode>
      <Code>function init(obj)
% This function is called after the object is created.
% OBJ is the device object.
% End of function definition - DO NOT EDIT
</Code>
   </CreateInitCode>
   <ConnectInitCode>
      <Type>MCode</Type>
      <Code>function init(obj)
% This function is called after the object is connected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT
</Code>
   </ConnectInitCode>
   <CleanupCode>
      <Type>MCode</Type>
      <Code>function cleanup(obj)
% This function is called before the object is disconnected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT
</Code>
   </CleanupCode>
   <GroupInfo>
      <Group>
         <Name>parent</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="parent1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>gethandle</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [InstrumentHandle] = gethandle(obj)

libname = get(obj, 'DriverName');
session = get(obj, 'Interface');
InstrumentHandle = libpointer('uint32Ptr', 0);

status = calllib(libname, 'hp816x_getHandle', session, InstrumentHandle);

InstrumentHandle = double(InstrumentHandle.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function returns the handle of hp816x. Use this function to
attach the instrument to the Pfl. 
</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>ApplicationsWavelengthScan</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="ApplicationsWavelengthScan1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>enablehighsweepspeed</Name>
               <Location>ApplicationsWavelengthScan</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function enablehighsweepspeed(obj, FastSweepSpeed)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_enableHighSweepSpeed', session, FastSweepSpeed);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Enable High Sweep Speed (hp816x_enableHighSweepSpeed) function enables/disables the highest available sweep speed (40 nanometers per second) for Lambda Scan operations. The Lambda Scan operation chooses the highest possible sweep speed for the chosen step size. 

If you choose Enable, the highest sweep speed possible will be used. This may lead to less accurate measurements. 

If you choose Disable, the highest sweep speed will not be used.</Description>
            </Method>
            <Method>
               <Name>setlambdascanwavelength</Name>
               <Location>ApplicationsWavelengthScan</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setlambdascanwavelength(obj, PowerMeterWavelength)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_LambdaScan_wavelength', session, PowerMeterWavelength);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set Lambda Scan Wavelength (hp816x_set_LambdaScan_wavelength) function allows you to use a different wavelength than 1550 nm during a Lambda Scan operation. All Power Meters taking part in the Lambda Scan operation will be set to the chosen wavelength.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>ApplicationsWavelengthScanFunctionsLambdaScan</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="ApplicationsWavelengthScanFunctionsLambdaScan1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>executelambdascan</Name>
               <Location>ApplicationsWavelengthScanFunctionsLambdaScan</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [WavelengthArray, PowerArray1, PowerArray2, PowerArray3, PowerArray4, PowerArray5, PowerArray6, PowerArray7, PowerArray8] = executelambdascan(obj, WavelengthArray, PowerArray1, PowerArray2, PowerArray3, PowerArray4, PowerArray5, PowerArray6, PowerArray7, PowerArray8)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
WavelengthArray = libpointer('doublePtr', WavelengthArray);
PowerArray1 = libpointer('doublePtr', PowerArray1);
PowerArray2 = libpointer('doublePtr', PowerArray2);
PowerArray3 = libpointer('doublePtr', PowerArray3);
PowerArray4 = libpointer('doublePtr', PowerArray4);
PowerArray5 = libpointer('doublePtr', PowerArray5);
PowerArray6 = libpointer('doublePtr', PowerArray6);
PowerArray7 = libpointer('doublePtr', PowerArray7);
PowerArray8 = libpointer('doublePtr', PowerArray8);

status = calllib(libname, 'hp816x_executeLambdaScan', session, WavelengthArray, PowerArray1, PowerArray2, PowerArray3, PowerArray4, PowerArray5, PowerArray6, PowerArray7, PowerArray8);

WavelengthArray = double(WavelengthArray.Value);
PowerArray1 = double(PowerArray1.Value);
PowerArray2 = double(PowerArray2.Value);
PowerArray3 = double(PowerArray3.Value);
PowerArray4 = double(PowerArray4.Value);
PowerArray5 = double(PowerArray5.Value);
PowerArray6 = double(PowerArray6.Value);
PowerArray7 = double(PowerArray7.Value);
PowerArray8 = double(PowerArray8.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Execute Lambda Scan (hp816x_executeLambdaScan) function runs and returns the results of a Lambda Scan operation. 

That is, it executes an operation where a Agilent 8164A Lightwave Measurement System with a back-loadable Tunable Laser module and up to four Power Sensors installed, performs a wavelength sweep where the Tunable Laser module and Power Sensors are coordinated with each other.

The Prepare Lambda Scan (hp816x_prepareLambdaScan) function must  be called before a Lambda Scan operation is executed. Use the return values of this function (Number of Datapoints and Number of Power Arrays) to allocate arrays for the Execute Lambda Scan (hp816x_executeLambdaScan) function.

Equally Spaced Datapoints is enabled as part of this function and cannot be disabled, see the Windows Help file or your Programming Guide for more details. Use Multi Frame Lambda Scan if you need to have inequally spaced datapoints.</Description>
            </Method>
            <Method>
               <Name>getlambdascanparametersq</Name>
               <Location>ApplicationsWavelengthScanFunctionsLambdaScan</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [StartWavelength, StopWavelength, AveragingTime, SweepSpeed] = getlambdascanparametersq(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
StartWavelength = libpointer('doublePtr', 0);
StopWavelength = libpointer('doublePtr', 0);
AveragingTime = libpointer('doublePtr', 0);
SweepSpeed = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_getLambdaScanParameters_Q', session, StartWavelength, StopWavelength, AveragingTime, SweepSpeed);

StartWavelength = double(StartWavelength.Value);
StopWavelength = double(StopWavelength.Value);
AveragingTime = double(AveragingTime.Value);
SweepSpeed = double(SweepSpeed.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get Lambda Scan Parameters (hp816x_getLambdaScanParameters_Q) function returns all parameters that the Prepare Lambda Scan (hp816x_prepareLambdaScan) function adjusts or automatically calculates.</Description>
            </Method>
            <Method>
               <Name>preparelambdascan</Name>
               <Location>ApplicationsWavelengthScanFunctionsLambdaScan</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [NumberofDatapoints, NumberofChannels] = preparelambdascan(obj, PowerUnit, Power, OpticalOutput, NumberofScans, PWMChannels, StartWavelength, StopWavelength, StepSize)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
NumberofDatapoints = libpointer('uint32Ptr', 0);
NumberofChannels = libpointer('uint32Ptr', 0);

status = calllib(libname, 'hp816x_prepareLambdaScan', session, PowerUnit, Power, OpticalOutput, NumberofScans, PWMChannels, StartWavelength, StopWavelength, StepSize, NumberofDatapoints, NumberofChannels);

NumberofDatapoints = double(NumberofDatapoints.Value);
NumberofChannels = double(NumberofChannels.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Prepare Lambda Scan (hp816x_prepareLambdaScan) function prepares a Lambda Scan operation. 

That is, it prepares an operation where a Agilent 8164A Lightwave Measurement System with a back-loadable Tunable Laser module and up to four Power Sensors installed, performs a wavelength sweep where the Tunable Laser module and Power Sensors are coordinated with each other.

The Prepare Lambda Scan (hp816x_prepareLambdaScan) function must  be called before a Lambda Scan operation is executed. Use the return values of this function (Number of Datapoints and Number of Power Arrays) to allocate arrays for the Execute Lambda Scan (hp816x_executeLambdaScan) function.

To obtain a higher precision, the Tunable Laser Source is set 1 nm before the Start Wavelength, this means, you have to choose a Start Wavelength 1 nm greater than the minimum possible wavelength. Also, the wavelength sweep is actually started 90 pm before the Start Wavelength and ends 90 pm after the Stop Wavelength, this means, you have to choose a Stop Wavelength 90 pm less than the maximum possible wavelength.

Triggers coordinate the Tunable Laser module with all Power Meters. The function sets for the lowest possible averaging time available for the installed Power Meters and, then, sets the highest possible sweep speed for the selected Tunable Laser module sweep.  

If one of the following circumstances occurs, the "parameter mismatch" error will be returned:
   
1. If one Power Meter is out of the specification at 1550 nm, the error "powermeter wavelength does not span 1550nm" will be returned. For example, the HP 81530A Power Sensor and the HP 81520A Optical Head are out of specification at 1550 nm. Remove the Power Meter that is out of specification at 1550 nm from the mainframe.

2. If the Step Size is too small and results in a trigger frequency that is to high for the installed Power Meters, the error "could not calculate a sweep speed!" will be returned. Increase the Step Size.

3. If the chosen wavelength range is too large and Step Size is too small, the error "too many datapoints to log!" will be returned. In this case, reduce the wavelength range and/or increase the Step Size.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>ApplicationsWavelengthScanFunctionsMultiFrameLambdaScan</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="ApplicationsWavelengthScanFunctionsMultiFrameLambdaScan1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>GetNoOfRegPWMChannels</Name>
               <Location>ApplicationsWavelengthScanFunctionsMultiFrameLambdaScan</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

[status, propertyValue] = calllib(libname, 'hp816x_getNoOfRegPWMChannels_Q', session, 0);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while getting the property value.\n%s', errorMessage)
end
propertyValue = double(propertyValue);</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>excludechannel</Name>
               <Location>ApplicationsWavelengthScanFunctionsMultiFrameLambdaScan</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function excludechannel(obj, PWMChannel, Exclude)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_excludeChannel', session, PWMChannel, Exclude);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Exclude Channel function (hp816x_excludeChannel) excludes a specified PWM channel from a Lambda Scan operation.
</Description>
            </Method>
            <Method>
               <Name>executemflambdascan</Name>
               <Location>ApplicationsWavelengthScanFunctionsMultiFrameLambdaScan</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [WavelengthArray] = executemflambdascan(obj, WavelengthArray)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
WavelengthArray = libpointer('doublePtr', WavelengthArray);

status = calllib(libname, 'hp816x_executeMfLambdaScan', session, WavelengthArray);

WavelengthArray = double(WavelengthArray.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Execute Multi Frame Lambda Scan (hp816x_executeMfLambdaScan) function runs a Lambda Scan operation and returns an array that contains the wavelength values at which power measurements are made. 

That is, it executes an operation where a Agilent 8164A Lightwave Measurement System with a back-loadable Tunable Laser module and up to 100 Power Sensors installed, performs a wavelength sweep where the Tunable Laser module and Power Sensors are coordinated with each other.

Use the values returned from the Prepare Multi Frame Lambda Scan (hp816x_prepareMfLambdaScan) function to set the parameters of the Execute Multi Frame Lambda Scan (hp816x_executeMfLambdaScan) function.</Description>
            </Method>
            <Method>
               <Name>getchannellocation</Name>
               <Location>ApplicationsWavelengthScanFunctionsMultiFrameLambdaScan</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [MainframeNumber, SlotNumber, ChannelNumber] = getchannellocation(obj, PWMChannel)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
MainframeNumber = libpointer('int32Ptr', 0);
SlotNumber = libpointer('int32Ptr', 0);
ChannelNumber = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_getChannelLocation', session, PWMChannel, MainframeNumber, SlotNumber, ChannelNumber);

MainframeNumber = double(MainframeNumber.Value);
SlotNumber = double(SlotNumber.Value);
ChannelNumber = double(ChannelNumber.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get Channel Location function (hp816x_getChannelLocation_Q) returns the location of the chosen Power Meter channel as used in a Multi Frame Lambda Scan operation.

The maximum number of channels that may be specified is 1000.</Description>
            </Method>
            <Method>
               <Name>getlambdascanresult</Name>
               <Location>ApplicationsWavelengthScanFunctionsMultiFrameLambdaScan</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [PowerArray, LambdaArray] = getlambdascanresult(obj, PWMChannel, CliptoLimit, ClippingLimit, PowerArray, LambdaArray)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
PowerArray = libpointer('doublePtr', PowerArray);
LambdaArray = libpointer('doublePtr', LambdaArray);

status = calllib(libname, 'hp816x_getLambdaScanResult', session, PWMChannel, CliptoLimit, ClippingLimit, PowerArray, LambdaArray);

PowerArray = double(PowerArray.Value);
LambdaArray = double(LambdaArray.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get Lambda Scan Result returns for a given Power Meter channel a power value array and a wavelength value array. 

These arrays contains the results of the last Multi Frame Lambda Scan operation.</Description>
            </Method>
            <Method>
               <Name>getmflambdascanparametersq</Name>
               <Location>ApplicationsWavelengthScanFunctionsMultiFrameLambdaScan</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [StartWavelength, StopWavelength, AveragingTime, SweepSpeed] = getmflambdascanparametersq(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
StartWavelength = libpointer('doublePtr', 0);
StopWavelength = libpointer('doublePtr', 0);
AveragingTime = libpointer('doublePtr', 0);
SweepSpeed = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_getMFLambdaScanParameters_Q', session, StartWavelength, StopWavelength, AveragingTime, SweepSpeed);

StartWavelength = double(StartWavelength.Value);
StopWavelength = double(StopWavelength.Value);
AveragingTime = double(AveragingTime.Value);
SweepSpeed = double(SweepSpeed.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get MF Lambda Scan Parameters (hp816x_getMFLambdaScanParameters_Q) function returns all parameters that the Prepare Multi Frame Lambda Scan (hp816x_prepareMfLambdaScan) function adjusts or automatically calculates.</Description>
            </Method>
            <Method>
               <Name>preparemflambdascan</Name>
               <Location>ApplicationsWavelengthScanFunctionsMultiFrameLambdaScan</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [NumberofDatapoints, NumberofChannels] = preparemflambdascan(obj, PowerUnit, Power, OpticalOutput, NumberofScans, PWMChannels, StartWavelength, StopWavelength, StepSize)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
NumberofDatapoints = libpointer('uint32Ptr', 0);
NumberofChannels = libpointer('uint32Ptr', 0);

status = calllib(libname, 'hp816x_prepareMfLambdaScan', session, PowerUnit, Power, OpticalOutput, NumberofScans, PWMChannels, StartWavelength, StopWavelength, StepSize, NumberofDatapoints, NumberofChannels);

NumberofDatapoints = double(NumberofDatapoints.Value);
NumberofChannels = double(NumberofChannels.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Prepare Multi Frame Lambda Scan (hp816x_prepareMfLambdaScan) function prepares a Lambda Scan operation for multiple Mainframes. 

That is, it prepares an operation where a Agilent 8164A Lightwave Measurement System with a back-loadable Tunable Laser module and up to 1000 Power Sensor Channels located in different Mainframes are installed. The function performs a wavelength sweep where the Tunable Laser module and Power Sensors are co-ordinated with each other.

The Prepare Multi Frame Lambda Scan (hp816x_prepareMfLambdaScan) function must be called before a Multi Frame Lambda Scan is executed. Use the return values of this function (Number of Datapoints and Number of Power Arrays) to allocate arrays for the Execute Multi Frame Lambda Scan (hp816x_executeMfLambdaScan) function.

The function scans all mainframes to find back-loadable Tunable Laser Sources. The function scans each mainframe in the order that they were originally registered by the Register Mainframe function (hp816x_registerMainframe). The first back-loadable Tunable Laser Source found will perform the sweep operation.

To obtain a higher precision, the wavelength sweep is started 90 pm before the Start Wavelength (or, if the Step Size is &gt; 90 pm, one step before the Start Wavelength) and ends 90 pm after the Stop Wavelength (or, if the Step Size is &gt; 90 pm, one step after the Stop Wavelength). This means that you have to choose a Stop Wavelength 90 pm less than the maximum possible wavelength (or, if the Step Size is &gt; 90 pm, one step less than the maximum possible wavelength).

Triggers coordinate the Tunable Laser module with all Power Meters. The function sets for the lowest possible averaging time available for the installed Power Meters and, then, sets the highest possible sweep speed for the selected Tunable Laser module sweep. All mainframes must be connected to the GPIB bus and have their Input Trigger Connector connected to the Output Trigger Connector of the Agilent 8164A Lightwave Measurement System mainframe that the Tunable Laser module is installed in.

If one of the following circumstances occurs, the "parameter mismatch" error will be returned:
   
1. If one Power Meter is out of the specification at 1550 nm, the error "powermeter wavelength does not span 1550nm" will be returned. For example, the HP 81530A Power Sensor and the HP 81520A Optical Head are out of specification at 1550 nm. Remove the Power Meter that is out of specification at 1550 nm from the mainframe.

2. If the Step Size is too small and results in a trigger frequency that is to high for the installed Power Meters, the error "could not calculate a sweep speed!" will be returned. Increase the Step Size.

3. If the chosen wavelength range is too large and Step Size is too small, the error "too many datapoints to log!" will be returned. In this case, reduce the wavelength range and/or increase the Step Size.</Description>
            </Method>
            <Method>
               <Name>registermainframe</Name>
               <Location>ApplicationsWavelengthScanFunctionsMultiFrameLambdaScan</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function registermainframe(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_registerMainframe', session);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use the Register Mainframe (hp816x_registerMainframe) function to register your mainframe as a participant in a
Multi Frame Lambda Scan operation. The mainframe must be connected to the GPIB bus and have its Input Trigger Connector connected to the Output Trigger Connector of the Agilent 8164A Lightwave Measurement System mainframe that the Tunable Laser module is installed in.

The IHandle for the session is internally registered and is used to identify the instrument for the Multi Frame Lambda Scan operation.</Description>
            </Method>
            <Method>
               <Name>returnequidistantdata</Name>
               <Location>ApplicationsWavelengthScanFunctionsMultiFrameLambdaScan</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function returnequidistantdata(obj, EquallySpacedDatapoints)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_returnEquidistantData', session, EquallySpacedDatapoints);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Equally Spaced Datapoints (hp816x_returnEquidistantData) function performs a linear interpolation on the wavelength point  and power measurement data and returns an equidistant wavelength array.

This function is used because Lambda Scan functions make use of Lambda Logging to log the exact wavelength that measurements were triggered at. This results in Lambda Array wavelength points that are not equally spaced.

NOTE: Lambda Logging is not available if your Tunable Laser module firmware revision is lower than 2.0.

Equally Spaced Datapoints is enabled as a default.</Description>
            </Method>
            <Method>
               <Name>setinitialrangeparams</Name>
               <Location>ApplicationsWavelengthScanFunctionsMultiFrameLambdaScan</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setinitialrangeparams(obj, PWMChannel, ResettoDefault, InitialRange, RangeDecrement)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_setInitialRangeParams', session, PWMChannel, ResettoDefault, InitialRange, RangeDecrement);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use the Set Initial Range Parameters function (hp816x_setInitialRangeParams) to set the Initial Range, and the Range Decrement, for a selected PWM Channel.

Call this function after Prepare Multi Frame Lambda Scan, and before Execute Multi Frame Lambda Scan. 

If this function is not called default values are used. 

The default value for the Initial Range used in a lambda scan depends on the initial power.
 
The default value for the Range Decrement in subsequent scans is 20.0 dBm</Description>
            </Method>
            <Method>
               <Name>setscanattenuation</Name>
               <Location>ApplicationsWavelengthScanFunctionsMultiFrameLambdaScan</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setscanattenuation(obj, ScanAttenuation)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_setScanAttenuation', session, ScanAttenuation);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use this function to set the attenuation of the backloadable
TLS during a lambdda scan operation</Description>
            </Method>
            <Method>
               <Name>setsweepspeed</Name>
               <Location>ApplicationsWavelengthScanFunctionsMultiFrameLambdaScan</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setsweepspeed(obj, SweepSpeed)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_setSweepSpeed', session, SweepSpeed);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function is used to set a sweep speed for a multiframe lambda scan. 
Prepare lambda scan checks, if the desired sweep speed meets the following condition:

Averageing Time (of all powermeters) less than
 (Step Size / Sweep Speed ) 

Remark:
Call this function before call Prepare Mf Lambda Scan</Description>
            </Method>
            <Method>
               <Name>unregistermainframe</Name>
               <Location>ApplicationsWavelengthScanFunctionsMultiFrameLambdaScan</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function unregistermainframe(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_unregisterMainframe', session);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use the Unregister Mainframe function (hp816x_unregisterMainframe) to remove a mainframe from a Multi Frame Lambda Scan operation and clear the driver's internal data structures. 

If you use LabView 5.0 the following items should be noted:

- All multi frame functions are not re-entrant, if the driver is running and initialized more than once, results may be unpredictable.

- To avoid wrong results, call the Unregister Mainframe function prior to the Initialize function (hp816x_init). This is especially necessary during program debugging, if the Close function (hp816x_close) is not called.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>Attenuators</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="Attenuators1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>attdisplaytooffset</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function attdisplaytooffset(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_ATT_displayToOffset', session, ATTSlot);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Display To OffSet function (hp816x_ATT_displayToOffset) reads the currently displayed attenuation then sets this, as a negative value, as the attenuation offset for the specified Attenuator.

Remark: The range limits of the Attenuator are displaced by this offset value.</Description>
            </Method>
            <Method>
               <Name>cpattreffromextpm</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function cpattreffromextpm(obj, ATTSlot, Slot, Channel)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_cp_ATT_refFromExtPM', session, ATTSlot, Slot, Channel);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Copy Ref. from Powermeter function (hp816x_cp_ATT_refFromExtPM) reads the power value from the reference powermeter and copies this value to the reference power of the specified Attenuator.

Remark: This function is only applied to Attenuator modules without power control.</Description>
            </Method>
            <Method>
               <Name>getattabspowermodeq</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [AbsolutePowerMode] = getattabspowermodeq(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
AbsolutePowerMode = libpointer('uint16Ptr', 0);

status = calllib(libname, 'hp816x_get_ATT_absPowerMode_Q', session, ATTSlot, AbsolutePowerMode);

AbsolutePowerMode = double(AbsolutePowerMode.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Queries the current operation mode.</Description>
            </Method>
            <Method>
               <Name>getattattenuationoffsetq</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Minimum, Maximum, Default, Current] = getattattenuationoffsetq(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Minimum = libpointer('doublePtr', 0);
Maximum = libpointer('doublePtr', 0);
Default = libpointer('doublePtr', 0);
Current = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_ATT_attenuationOffset_Q', session, ATTSlot, Minimum, Maximum, Default, Current);

Minimum = double(Minimum.Value);
Maximum = double(Maximum.Value);
Default = double(Default.Value);
Current = double(Current.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Queries the attenuation offset factor. </Description>
            </Method>
            <Method>
               <Name>getattattenuationq</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Minimum, Maximum, Default, Current] = getattattenuationq(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Minimum = libpointer('doublePtr', 0);
Maximum = libpointer('doublePtr', 0);
Default = libpointer('doublePtr', 0);
Current = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_ATT_attenuation_Q', session, ATTSlot, Minimum, Maximum, Default, Current);

Minimum = double(Minimum.Value);
Maximum = double(Maximum.Value);
Default = double(Default.Value);
Current = double(Current.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function queries the current user attenuation factor and the device limits</Description>
            </Method>
            <Method>
               <Name>getattattenuatorspeedq</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Minimum, Maximum, Default, Current] = getattattenuatorspeedq(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Minimum = libpointer('doublePtr', 0);
Maximum = libpointer('doublePtr', 0);
Default = libpointer('doublePtr', 0);
Current = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_ATT_attenuatorSpeed_Q', session, ATTSlot, Minimum, Maximum, Default, Current);

Minimum = double(Minimum.Value);
Maximum = double(Maximum.Value);
Default = double(Default.Value);
Current = double(Current.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Queries filter transition speed and device limits.</Description>
            </Method>
            <Method>
               <Name>getattoperstatus</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Value, ConditionalInfo] = getattoperstatus(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Value = libpointer('uint32Ptr', 0);
ConditionalInfo = libpointer('int8Ptr', repmat(10, 1, 512));

status = calllib(libname, 'hp816x_get_ATT_operStatus', session, ATTSlot, Value, ConditionalInfo);

Value = double(Value.Value);
ConditionalInfo = strtrim(char(ConditionalInfo.Value));

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use the Get Operational Status function (hp816x_get_ATT_operStatus) to query the operational status register and return attenuator-specific status information. To be certain that the Attenuator module is not in an inoperable state, you should also call the Get Module Status function (hp816x_getModule Status_Q).</Description>
            </Method>
            <Method>
               <Name>getattpowerq</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [PowerControl, PowerUnit, Minimum, Maximum, Default, Current] = getattpowerq(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
PowerControl = libpointer('uint16Ptr', 0);
PowerUnit = libpointer('uint16Ptr', 0);
Minimum = libpointer('doublePtr', 0);
Maximum = libpointer('doublePtr', 0);
Default = libpointer('doublePtr', 0);
Current = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_ATT_power_Q', session, ATTSlot, PowerControl, PowerUnit, Minimum, Maximum, Default, Current);

PowerControl = double(PowerControl.Value);
PowerUnit = double(PowerUnit.Value);
Minimum = double(Minimum.Value);
Maximum = double(Maximum.Value);
Default = double(Default.Value);
Current = double(Current.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Queries the through power values and device limits.</Description>
            </Method>
            <Method>
               <Name>getattpowerreferenceq</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Minimum, Maximum, Default, Current] = getattpowerreferenceq(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Minimum = libpointer('doublePtr', 0);
Maximum = libpointer('doublePtr', 0);
Default = libpointer('doublePtr', 0);
Current = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_ATT_powerReference_Q', session, ATTSlot, Minimum, Maximum, Default, Current);

Minimum = double(Minimum.Value);
Maximum = double(Maximum.Value);
Default = double(Default.Value);
Current = double(Current.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Queries the reference power and the device limits. This function doesnot apply the attenuators with builtin powermeters.</Description>
            </Method>
            <Method>
               <Name>getattpowerunitq</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Unit] = getattpowerunitq(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Unit = libpointer('uint16Ptr', 0);

status = calllib(libname, 'hp816x_get_ATT_powerUnit_Q', session, ATTSlot, Unit);

Unit = double(Unit.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use this function to query the power unit.</Description>
            </Method>
            <Method>
               <Name>getattshutterstateatpoweronq</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [ShutterState] = getattshutterstateatpoweronq(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
ShutterState = libpointer('uint16Ptr', 0);

status = calllib(libname, 'hp816x_get_ATT_shutterStateAtPowerOn_Q', session, ATTSlot, ShutterState);

ShutterState = double(ShutterState.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Queries the output path state at power on.</Description>
            </Method>
            <Method>
               <Name>getattshutterstateq</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [ShutterState] = getattshutterstateq(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
ShutterState = libpointer('uint16Ptr', 0);

status = calllib(libname, 'hp816x_get_ATT_shutterState_Q', session, ATTSlot, ShutterState);

ShutterState = double(ShutterState.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Queries the state of the output path.</Description>
            </Method>
            <Method>
               <Name>getattwavelengthq</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Minimum, Maximum, Default, Current] = getattwavelengthq(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Minimum = libpointer('doublePtr', 0);
Maximum = libpointer('doublePtr', 0);
Default = libpointer('doublePtr', 0);
Current = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_ATT_wavelength_Q', session, ATTSlot, Minimum, Maximum, Default, Current);

Minimum = double(Minimum.Value);
Maximum = double(Maximum.Value);
Default = double(Default.Value);
Current = double(Current.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use the Get Wavelength function (hp816x_get_ATT_wavelength_Q) to query the wavelength calibration for the specified Attenuator module, including its device limits.

If a powermeter is integrated into the Attenuator module, this wavelength setting applies to both the Attenuator filter calibration and the powermeter.

If the wavelength:offset table is activated, this wavelenght setting also applies the corresonding offset.</Description>
            </Method>
            <Method>
               <Name>setattabspowermode</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setattabspowermode(obj, ATTSlot, AbsolutePowerMode)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_ATT_absPowerMode', session, ATTSlot, AbsolutePowerMode);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use the Set Absolute Power Mode function (hp816x_set_ATT_absPowerMode) to set the operation mode of the specified Attenuator module. 
This command exists for compatibility with the Agilent 8156A Attenuator.</Description>
            </Method>
            <Method>
               <Name>setattattenuation</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setattattenuation(obj, ATTSlot, Selection, Attenuation, WaitforCompletion)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_ATT_attenuation', session, ATTSlot, Selection, Attenuation, WaitforCompletion);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function sets attenuation of the attenuator module;

Adjusting attenuation also adjusts the filter attenuation:

a Filter(new) = a(new) - a Offset

and power CALCULATED using:

P[dBm] = Pref[dBm] - a Filter

While the filter is moving to its new position, the status line displays "Busy" (8164) or "B" (8163, 8166).</Description>
            </Method>
            <Method>
               <Name>setattattenuationoffset</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setattattenuationoffset(obj, ATTSlot, Selection, Offset)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_ATT_attenuationOffset', session, ATTSlot, Selection, Offset);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Sets the attenuation offset factor.

Remark:
This function changes the range of the attenuator and impacts that limits are recalculated.</Description>
            </Method>
            <Method>
               <Name>setattattenuatorspeed</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setattattenuatorspeed(obj, ATTSlot, Selection, Speed)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_ATT_attenuatorSpeed', session, ATTSlot, Selection, Speed);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Sets filter transition speed. How long it takes to switch from one attenuation to another.
The filter changes its attenuation with this speed in dB/s</Description>
            </Method>
            <Method>
               <Name>setattpower</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setattpower(obj, ATTSlot, PowerControl, PowerUnit, Selection, Power)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_ATT_power', session, ATTSlot, PowerControl, PowerUnit, Selection, Power);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use the Set Power (hp816x_set_ATT_power) to set a new power. 

If you have an Attenuator module with power control, you can activate the power control mode so that the Attenuator module automatically corrects for changes to input power, so maintaining the desired output power.

If you have an Attenuator module without power control, a reference calibration must be set, using hp816x_set_ATT_powerReference. 

Remark:
Because this function may take some time until the new power setting is completed, it is recommanded to query the OPC status.</Description>
            </Method>
            <Method>
               <Name>setattpowerreference</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setattpowerreference(obj, ATTSlot, Selection, Reference)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_ATT_powerReference', session, ATTSlot, Selection, Reference);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Sets the reference power. This function doesnot apply the attenuators with builtin powermeters.</Description>
            </Method>
            <Method>
               <Name>setattpowerunit</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setattpowerunit(obj, ATTSlot, Unit)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_ATT_powerUnit', session, ATTSlot, Unit);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use this fuction to set the power unit of the attenuator module.</Description>
            </Method>
            <Method>
               <Name>setattshutteratpoweron</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setattshutteratpoweron(obj, ATTSlot, ShutterState)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_ATT_shutterAtPowerOn', session, ATTSlot, ShutterState);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Sets the output path state at power on.</Description>
            </Method>
            <Method>
               <Name>setattshutterstate</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setattshutterstate(obj, ATTSlot, ShutterState)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_ATT_shutterState', session, ATTSlot, ShutterState);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Sets the state of the output path, resp. the shutter state.</Description>
            </Method>
            <Method>
               <Name>setattwavelength</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setattwavelength(obj, ATTSlot, Selection, Wavelength)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_ATT_wavelength', session, ATTSlot, Selection, Wavelength);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use the Set Wavelength function (hp816x_set_ATT_wavelength) to set the wavelength used by the Attenuator module. The Attenuator module is factory calibrated for wavelength dependencies.

If a powermeter is integrated into the Attenuator module, this wavelength setting applies to both the Attenuator filter calibration and the powermeter.

If the wavelength:offset table is activated, this wavelenght setting also applies the corresponding offset.</Description>
            </Method>
            <Method>
               <Name>zeroattall</Name>
               <Location>Attenuators</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function zeroattall(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_zero_ATT_all', session);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use the Zero All function (hp816x_zero_ATT_all) to zero all powermeters (including the powermeter built-in to each Attenuator module with Power Control,  and returnloss modules).</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>AttenuatorsBuiltinPowermeterControl</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="AttenuatorsBuiltinPowermeterControl1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>fetchattoutputpower</Name>
               <Location>AttenuatorsBuiltinPowermeterControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [OutputPower] = fetchattoutputpower(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
OutputPower = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_fetch_ATT_outputPower', session, ATTSlot, OutputPower);

OutputPower = double(OutputPower.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Fetch ATT Output Power function (hp816x_fetch_ATT_outputPower) immediately returns an output power value without averaging measurements over the averaging time period. 

REMARKS:
If this function is called more than once within an averaging cycle, the returned values will be identical.
</Description>
            </Method>
            <Method>
               <Name>getattavtimeq</Name>
               <Location>AttenuatorsBuiltinPowermeterControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [AveragingTime] = getattavtimeq(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
AveragingTime = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_ATT_avTime_Q', session, ATTSlot, AveragingTime);

AveragingTime = double(AveragingTime.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use this function to query the actual averaging time set in the builtin powermeter.</Description>
            </Method>
            <Method>
               <Name>getattcontrolloopstateq</Name>
               <Location>AttenuatorsBuiltinPowermeterControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [ControlLoopState] = getattcontrolloopstateq(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
ControlLoopState = libpointer('uint16Ptr', 0);

status = calllib(libname, 'hp816x_get_ATT_controlLoopState_Q', session, ATTSlot, ControlLoopState);

ControlLoopState = double(ControlLoopState.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use this function to query the power control loop state.
</Description>
            </Method>
            <Method>
               <Name>getattpoweroffsetq</Name>
               <Location>AttenuatorsBuiltinPowermeterControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Minimum, Maximum, Default, Current] = getattpoweroffsetq(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Minimum = libpointer('doublePtr', 0);
Maximum = libpointer('doublePtr', 0);
Default = libpointer('doublePtr', 0);
Current = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_ATT_powerOffset_Q', session, ATTSlot, Minimum, Maximum, Default, Current);

Minimum = double(Minimum.Value);
Maximum = double(Maximum.Value);
Default = double(Default.Value);
Current = double(Current.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function returns the power offset limits and actual setting.</Description>
            </Method>
            <Method>
               <Name>getatttriggerconfigq</Name>
               <Location>AttenuatorsBuiltinPowermeterControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [TriggerIn] = getatttriggerconfigq(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
TriggerIn = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_get_ATT_triggerConfig_Q', session, ATTSlot, TriggerIn);

TriggerIn = double(TriggerIn.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get ATT Trigger Configuration (hp816x_get_PWM_triggerConfiguration) function returns the input  input trigger configuraation of an sttenuator module.</Description>
            </Method>
            <Method>
               <Name>getattzeroresultq</Name>
               <Location>AttenuatorsBuiltinPowermeterControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [LastZeroResult] = getattzeroresultq(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
LastZeroResult = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_get_ATT_zeroResult_Q', session, ATTSlot, LastZeroResult);

LastZeroResult = double(LastZeroResult.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use this function to query the result of the last zeroing operation for the builtin powermeter.</Description>
            </Method>
            <Method>
               <Name>readattoutputpower</Name>
               <Location>AttenuatorsBuiltinPowermeterControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [OutputPower] = readattoutputpower(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
OutputPower = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_read_ATT_outputPower', session, ATTSlot, OutputPower);

OutputPower = double(OutputPower.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Read ATT Output Power function (hp816x_read_ATT_outputPower) forces the builtin powermeter to start a measurement cycle. The evaluated output power will not be returned, until the averaging time period is finished.</Description>
            </Method>
            <Method>
               <Name>setattavtime</Name>
               <Location>AttenuatorsBuiltinPowermeterControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setattavtime(obj, ATTSlot, AveragingTime)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_ATT_avTime', session, ATTSlot, AveragingTime);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use this function to set the averaging time of the builtin powermeter.</Description>
            </Method>
            <Method>
               <Name>setattcontrolloopstate</Name>
               <Location>AttenuatorsBuiltinPowermeterControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setattcontrolloopstate(obj, ATTSlot, ControlLoop)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_ATT_controlLoopState', session, ATTSlot, ControlLoop);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use this function to enable / disable the power control loop.</Description>
            </Method>
            <Method>
               <Name>setattoffsbyrefpm</Name>
               <Location>AttenuatorsBuiltinPowermeterControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setattoffsbyrefpm(obj, ATTSlot, Slot, Channel)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_ATT_offsByRefPM', session, ATTSlot, Slot, Channel);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use Set Att. Offs. by Ext PM to calculate an attenuation offset factor by using the difference of an external powermeter and internal current power.
The result is used as attenuation offset factor.</Description>
            </Method>
            <Method>
               <Name>setattpoweroffset</Name>
               <Location>AttenuatorsBuiltinPowermeterControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setattpoweroffset(obj, ATTSlot, Selection, Offset)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_ATT_powerOffset', session, ATTSlot, Selection, Offset);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use the Set Power Offset function (hp816x_set_ATT_powerOffset ) to set the offset factor applied to the power measured at the attenuator module. This factor does not affect the Attenuator module's filter, or its power output.

Pset = Pout -Poffset

Remark: This function only applies to Attenuator modules with power control.</Description>
            </Method>
            <Method>
               <Name>setattpwroffsrefpm</Name>
               <Location>AttenuatorsBuiltinPowermeterControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setattpwroffsrefpm(obj, ATTSlot, PWMSlot, PWMChannel)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_ATT_pwrOffsRefPM', session, ATTSlot, PWMSlot, PWMChannel);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use this function to calculate a power offset factor by using the builtin Powermeter and an external specified powermeter;
The  difference Cal = P out - P ext is copied to the power offset;
</Description>
            </Method>
            <Method>
               <Name>setatttriggerconfig</Name>
               <Location>AttenuatorsBuiltinPowermeterControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setatttriggerconfig(obj, ATTSlot, TriggerIn)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_ATT_triggerConfig', session, ATTSlot, TriggerIn);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set ATT Trigger Configuration (hp816x_set_ATT_triggerConfiguration) function configures the input trigger handling for a builtin powermeter of an attenuator.</Description>
            </Method>
            <Method>
               <Name>zeroattpowermeter</Name>
               <Location>AttenuatorsBuiltinPowermeterControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function zeroattpowermeter(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_zero_ATT_powermeter', session, ATTSlot);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function zeroes the builtin powermeter</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>AttenuatorsBuiltinPowermeterControlMultiWavelengthCalibration</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="AttenuatorsBuiltinPowermeterControlMultiWavelengthCalibration1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>getwlresptblsize</Name>
               <Location>AttenuatorsBuiltinPowermeterControlMultiWavelengthCalibration</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Size, CSVSize] = getwlresptblsize(obj, Slot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Size = libpointer('uint32Ptr', 0);
CSVSize = libpointer('uint32Ptr', 0);

status = calllib(libname, 'hp816x_getWlRespTblSize', session, Slot, Size, CSVSize);

Size = double(Size.Value);
CSVSize = double(CSVSize.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function returns the size of the wavelength response table, for different formats.</Description>
            </Method>
            <Method>
               <Name>readwlreptblcsv</Name>
               <Location>AttenuatorsBuiltinPowermeterControlMultiWavelengthCalibration</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function readwlreptblcsv(obj, Slot, CSVList)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
CSVList = [double(CSVList) 0];

status = calllib(libname, 'hp816x_readWlRepTblCSV', session, Slot, CSVList);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>his function returns the calibrated wavelength response table as a comma separated values. The size of the table can be queried calling the function Get Wavelength Rep. Tbl. Size.</Description>
            </Method>
            <Method>
               <Name>readwlresptable</Name>
               <Location>AttenuatorsBuiltinPowermeterControlMultiWavelengthCalibration</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Wavelength, ResponseFactor] = readwlresptable(obj, Slot, Wavelength, ResponseFactor)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Wavelength = libpointer('doublePtr', Wavelength);
ResponseFactor = libpointer('doublePtr', ResponseFactor);

status = calllib(libname, 'hp816x_readWlRespTable', session, Slot, Wavelength, ResponseFactor);

Wavelength = double(Wavelength.Value);
ResponseFactor = double(ResponseFactor.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function returns the calibrated wavelength response table . The size of the table can be queried calling the function Get Wavelength Rep. Tbl. Size.</Description>
            </Method>
            <Method>
               <Name>spectralcalibration</Name>
               <Location>AttenuatorsBuiltinPowermeterControlMultiWavelengthCalibration</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [WavelengthResult, ErrorDiagnose] = spectralcalibration(obj, Slot, SizeofSpectrum, Wavelength, Power)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
WavelengthResult = libpointer('doublePtr', 0);
ErrorDiagnose = libpointer('int8Ptr', repmat(10, 1, 512));

status = calllib(libname, 'hp816x_spectralCalibration', session, Slot, SizeofSpectrum, Wavelength, Power, WavelengthResult, ErrorDiagnose);

WavelengthResult = double(WavelengthResult.Value);
ErrorDiagnose = strtrim(char(ErrorDiagnose.Value));

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function calculates and sets the wavelength of the monitor
powermeter for an attenuator module with a builtin powermeter.
For this calculation the spectrum of the used laser source is needed.
 </Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>AttenuatorsWavelengthOffsetTableControl</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="AttenuatorsWavelengthOffsetTableControl1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>deleteattoffsettblentries</Name>
               <Location>AttenuatorsWavelengthOffsetTableControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function deleteattoffsettblentries(obj, ATTSlot, NoOfEntries, WavelengthOrIndex)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_delete_ATT_offsetTblEntries', session, ATTSlot, NoOfEntries, WavelengthOrIndex);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use this function to delete entries of the wavelength-offset table of the attenuator.</Description>
            </Method>
            <Method>
               <Name>getattoffsetfromwavelengthq</Name>
               <Location>AttenuatorsWavelengthOffsetTableControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Offset] = getattoffsetfromwavelengthq(obj, ATTSlot, Wavelength)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Offset = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_ATT_offsetFromWavelength_Q', session, ATTSlot, Wavelength, Offset);

Offset = double(Offset.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function returns for a given wavelength the offset.</Description>
            </Method>
            <Method>
               <Name>getattoffsettableq</Name>
               <Location>AttenuatorsWavelengthOffsetTableControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [WavelengthArray, OffsetArray] = getattoffsettableq(obj, ATTSlot, WavelengthArray, OffsetArray)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
WavelengthArray = libpointer('doublePtr', WavelengthArray);
OffsetArray = libpointer('doublePtr', OffsetArray);

status = calllib(libname, 'hp816x_get_ATT_offsetTable_Q', session, ATTSlot, WavelengthArray, OffsetArray);

WavelengthArray = double(WavelengthArray.Value);
OffsetArray = double(OffsetArray.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function returns the wavelength offset table of the attenuator.</Description>
            </Method>
            <Method>
               <Name>getattoffsettblsizeq</Name>
               <Location>AttenuatorsWavelengthOffsetTableControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [CurrentSize, MaximumSize] = getattoffsettblsizeq(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
CurrentSize = libpointer('uint32Ptr', 0);
MaximumSize = libpointer('uint32Ptr', 0);

status = calllib(libname, 'hp816x_get_ATT_offsetTblSize_Q', session, ATTSlot, CurrentSize, MaximumSize);

CurrentSize = double(CurrentSize.Value);
MaximumSize = double(MaximumSize.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This functions returns the wavelength-offset table dimensions.</Description>
            </Method>
            <Method>
               <Name>getattwavelengthoffsetindexq</Name>
               <Location>AttenuatorsWavelengthOffsetTableControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Wavelength, Offset] = getattwavelengthoffsetindexq(obj, ATTSlot, TableIndex)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Wavelength = libpointer('doublePtr', 0);
Offset = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_ATT_wavelengthOffsetIndex_Q', session, ATTSlot, TableIndex, Wavelength, Offset);

Wavelength = double(Wavelength.Value);
Offset = double(Offset.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function returns the wavelength and the corresponding offset for a given table index.</Description>
            </Method>
            <Method>
               <Name>getattwavelengthoffsetstateq</Name>
               <Location>AttenuatorsWavelengthOffsetTableControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [OffsetDependancy] = getattwavelengthoffsetstateq(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
OffsetDependancy = libpointer('uint16Ptr', 0);

status = calllib(libname, 'hp816x_get_ATT_wavelengthOffsetState_Q', session, ATTSlot, OffsetDependancy);

OffsetDependancy = double(OffsetDependancy.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use this function, to request, if the wavelength-offset table is  used.</Description>
            </Method>
            <Method>
               <Name>getattwloffsrefpowermeterq</Name>
               <Location>AttenuatorsWavelengthOffsetTableControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Slot, Channel] = getattwloffsrefpowermeterq(obj, ATTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Slot = libpointer('int32Ptr', 0);
Channel = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_get_ATT_wlOffsRefPowermeter_Q', session, ATTSlot, Slot, Channel);

Slot = double(Slot.Value);
Channel = double(Channel.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use this function to query the reference powermeter.</Description>
            </Method>
            <Method>
               <Name>setattwavelengthoffset</Name>
               <Location>AttenuatorsWavelengthOffsetTableControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setattwavelengthoffset(obj, ATTSlot, Wavelength, OffsetSource, OffsetValue)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_ATT_wavelengthOffset', session, ATTSlot, Wavelength, OffsetSource, OffsetValue);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use this function to set for a specific wavelength a corresponding offset. If this specific wavelength is set and wavelength-offset dependancy is turned on, the entered offset is used. 
A call of this function generates an entry in the wavelength-offset table of the attenuator. 

Remark:
If for the given wavelength an entry already exists, the offset for this wavelength is overwritten. 
 </Description>
            </Method>
            <Method>
               <Name>setattwavelengthoffsetstate</Name>
               <Location>AttenuatorsWavelengthOffsetTableControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setattwavelengthoffsetstate(obj, ATTSlot, OffsetDependant)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_ATT_wavelengthOffsetState', session, ATTSlot, OffsetDependant);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use the Set Wavelength Offset State function (hp816x_set_ATT_wavelengthOffsetState) to turn the Attenuator module's wavelength offset table on(off).</Description>
            </Method>
            <Method>
               <Name>setattwloffsrefpowermeter</Name>
               <Location>AttenuatorsWavelengthOffsetTableControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setattwloffsrefpowermeter(obj, ATTSlot, Slot, Channel)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_ATT_wlOffsRefPowermeter', session, ATTSlot, Slot, Channel);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use the Set Wavel. Offs. Ref. PM function (hp816x_set_ATT_wlOffsRefPowermeter) to specify the external powermeter (hosted by the same mainframe as the Attenuator module ) used for determine offsets for particular wavelengths. This function works in conjunction with the Set Wavelength Offset function when the TOREF control is active. (hp816x_set_ATT_wavelengthOffset)

</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>FixedLaserSources</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="FixedLaserSources1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>getflsattenuationq</Name>
               <Location>FixedLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [AttenuationLowerSource, AttenuationUpperSource] = getflsattenuationq(obj, FLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
AttenuationLowerSource = libpointer('doublePtr', 0);
AttenuationUpperSource = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_FLS_attenuation_Q', session, FLSSlot, AttenuationLowerSource, AttenuationUpperSource);

AttenuationLowerSource = double(AttenuationLowerSource.Value);
AttenuationUpperSource = double(AttenuationUpperSource.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get FLS Attenuation function (hp816x_get_FLS_attenuation_Q) returns the set attenuation of a Fixed Laser Source.</Description>
            </Method>
            <Method>
               <Name>getflslasersourceq</Name>
               <Location>FixedLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [LaserSource] = getflslasersourceq(obj, FLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
LaserSource = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_get_FLS_laserSource_Q', session, FLSSlot, LaserSource);

LaserSource = double(LaserSource.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get Laser Source function (hp816x_get_FLS_laserSource_Q) returns, for dual-wavelength Fixed Laser Sources, which wavelength is switched to the output. 

This function is irrelevant for a single-wavelength Fixed Laser Source.</Description>
            </Method>
            <Method>
               <Name>getflslaserstateq</Name>
               <Location>FixedLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [LaserState] = getflslaserstateq(obj, FLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
LaserState = libpointer('uint16Ptr', 0);

status = calllib(libname, 'hp816x_get_FLS_laserState_Q', session, FLSSlot, LaserState);

LaserState = double(LaserState.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get FLS Laser State function (hp816x_get_FLS_laserState_Q) returns whether the laser is turned on or off.</Description>
            </Method>
            <Method>
               <Name>getflsmodulationsettingsq</Name>
               <Location>FixedLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [ModulationState, ModulationSource, MinimumFrequency, MaximumFrequency, DefaultFrequency, CurrentFrequency] = getflsmodulationsettingsq(obj, FLSSlot, WavelengthSource)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
ModulationState = libpointer('uint16Ptr', 0);
ModulationSource = libpointer('int32Ptr', 0);
MinimumFrequency = libpointer('doublePtr', 0);
MaximumFrequency = libpointer('doublePtr', 0);
DefaultFrequency = libpointer('doublePtr', 0);
CurrentFrequency = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_FLS_modulationSettings_Q', session, FLSSlot, WavelengthSource, ModulationState, ModulationSource, MinimumFrequency, MaximumFrequency, DefaultFrequency, CurrentFrequency);

ModulationState = double(ModulationState.Value);
ModulationSource = double(ModulationSource.Value);
MinimumFrequency = double(MinimumFrequency.Value);
MaximumFrequency = double(MaximumFrequency.Value);
DefaultFrequency = double(DefaultFrequency.Value);
CurrentFrequency = double(CurrentFrequency.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get FLS Modulation Settings function (hp816x_get_FLS_modulationSettings_Q) returns the current values of the following: Modulation State, Minimum Frequency, Maximum Frequency, Default Frequency, and Current Frequency.</Description>
            </Method>
            <Method>
               <Name>getflsparametersq</Name>
               <Location>FixedLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [WavelengthSource, TurnLaser, ModulationLowerSource, ModulationUpperSource, ModulationFreqLowerSource, ModulationFreqUpperSource, AttenuationLowerSource, AttenuationUpperSource] = getflsparametersq(obj, FLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
WavelengthSource = libpointer('int32Ptr', 0);
TurnLaser = libpointer('uint16Ptr', 0);
ModulationLowerSource = libpointer('int32Ptr', 0);
ModulationUpperSource = libpointer('int32Ptr', 0);
ModulationFreqLowerSource = libpointer('doublePtr', 0);
ModulationFreqUpperSource = libpointer('doublePtr', 0);
AttenuationLowerSource = libpointer('doublePtr', 0);
AttenuationUpperSource = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_FLS_parameters_Q', session, FLSSlot, WavelengthSource, TurnLaser, ModulationLowerSource, ModulationUpperSource, ModulationFreqLowerSource, ModulationFreqUpperSource, AttenuationLowerSource, AttenuationUpperSource);

WavelengthSource = double(WavelengthSource.Value);
TurnLaser = double(TurnLaser.Value);
ModulationLowerSource = double(ModulationLowerSource.Value);
ModulationUpperSource = double(ModulationUpperSource.Value);
ModulationFreqLowerSource = double(ModulationFreqLowerSource.Value);
ModulationFreqUpperSource = double(ModulationFreqUpperSource.Value);
AttenuationLowerSource = double(AttenuationLowerSource.Value);
AttenuationUpperSource = double(AttenuationUpperSource.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set FLS Parameters function (hp816x_set_FLS_parameters)  enables you to set up Laser Sources quickly.
In case of a Laser Source with a single optical output, the inputs for the lower source will be used.</Description>
            </Method>
            <Method>
               <Name>getflspower</Name>
               <Location>FixedLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [LaserPower] = getflspower(obj, FLSSlot, LaserSource)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
LaserPower = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_FLS_power', session, FLSSlot, LaserSource, LaserPower);

LaserPower = double(LaserPower.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get FLS Power function (hp816x_get_FLS_power_Q) returns the output power of a fixed-wavelength Laser Source in Watts.</Description>
            </Method>
            <Method>
               <Name>getflstriggerstateq</Name>
               <Location>FixedLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [OutputTrigger] = getflstriggerstateq(obj, FLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
OutputTrigger = libpointer('uint16Ptr', 0);

status = calllib(libname, 'hp816x_get_FLS_triggerState_Q', session, FLSSlot, OutputTrigger);

OutputTrigger = double(OutputTrigger.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get FLS Trigger State (hp816x_get_FLS_triggerState) function returns whether an output trigger is generated for every leading edge of a digitally-modulated TTL signal.</Description>
            </Method>
            <Method>
               <Name>getflswavelengthq</Name>
               <Location>FixedLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [WavelengthLowerSource, WavelengthUpperSource] = getflswavelengthq(obj, FLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
WavelengthLowerSource = libpointer('doublePtr', 0);
WavelengthUpperSource = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_FLS_wavelength_Q', session, FLSSlot, WavelengthLowerSource, WavelengthUpperSource);

WavelengthLowerSource = double(WavelengthLowerSource.Value);
WavelengthUpperSource = double(WavelengthUpperSource.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get FLS Wavelength function (hp816x_get_FLS_wavelength_Q) returns the wavelength of a Fixed Laser Source.
 
REMARK:

Wavelength Upper Source returns 0.0 if a single-wavelength Fixed Laser Source is installed.
</Description>
            </Method>
            <Method>
               <Name>setflsattenuation</Name>
               <Location>FixedLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setflsattenuation(obj, FLSSlot, AttenuationLowerSource, AttenuationUpperSource)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_FLS_attenuation', session, FLSSlot, AttenuationLowerSource, AttenuationUpperSource);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set FLS Attenuation function (hp816x_set_FLS_attenuation) sets the attenuation of a Fixed Laser Source.</Description>
            </Method>
            <Method>
               <Name>setflslasersource</Name>
               <Location>FixedLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setflslasersource(obj, FLSSlot, LaserSource)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_FLS_laserSource', session, FLSSlot, LaserSource);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set FLS Laser Source function (hp816x_set_FLS_laserSource) chooses, which laser output, of a dual-wavelength Fixed Laser Source, is output. 

This function is irrelevant for single-wavelength Fixed Laser Sources.</Description>
            </Method>
            <Method>
               <Name>setflslaserstate</Name>
               <Location>FixedLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setflslaserstate(obj, FLSSlot, LaserState)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_FLS_laserState', session, FLSSlot, LaserState);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set FLS Laser State function (hp816x_set_FLS_laserState) turns the laser on or off.</Description>
            </Method>
            <Method>
               <Name>setflsmodulation</Name>
               <Location>FixedLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setflsmodulation(obj, FLSSlot, LaserSource, ModulationFrequency, ModulationSource, ManualFrequency)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_FLS_modulation', session, FLSSlot, LaserSource, ModulationFrequency, ModulationSource, ManualFrequency);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Setup FLS Modulation function (hp816x_set_FLS_modulation) adjusts the internal modulation of a Fixed Laser Source.

Internal Modulation is described in your instrument's User's Guide.</Description>
            </Method>
            <Method>
               <Name>setflsparameters</Name>
               <Location>FixedLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setflsparameters(obj, FLSSlot, WavelengthSource, TurnLaser, ModulationLowerSource, ModulationUpperSource, ModulationFreqLowerSource, ModulationFreqUpperSource, AttenuationLowerSource, AttenuationUpperSource)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_FLS_parameters', session, FLSSlot, WavelengthSource, TurnLaser, ModulationLowerSource, ModulationUpperSource, ModulationFreqLowerSource, ModulationFreqUpperSource, AttenuationLowerSource, AttenuationUpperSource);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set FLS Parameters function (hp816x_set_FLS_parameters)  enables you to set up Laser Sources quickly.
In case of a Single-Wavelength Laser Source Module, the inputs for the lower source will be used.

Remark:
For dual-wavelength Laser Sources with part numbers less than 81600, the modulation settings for the upper source will be ignored; only the lower source modulation setings are valid.</Description>
            </Method>
            <Method>
               <Name>setflstriggerstate</Name>
               <Location>FixedLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setflstriggerstate(obj, FLSSlot, OutputTrigger)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_FLS_triggerState', session, FLSSlot, OutputTrigger);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set FLS Trigger State (hp816x_set_FLS_triggerState) function specifies when an output trigger is generated.

You can enable an output trigger to be generated for every leading edge of a digitally-modulated TTL signal.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>MainframeSpecific</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="MainframeSpecific1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>Opc</Name>
               <Location>MainframeSpecific</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

[status, propertyValue] = calllib(libname, 'hp816x_opc_Q', session, 0);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while getting the property value.\n%s', errorMessage)
end
propertyValue = double(propertyValue);</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Boolean</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>convertquestionablestatusq</Name>
               <Location>MainframeSpecific</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Message] = convertquestionablestatusq(obj, QuestionableStatusInput)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Message = libpointer('int8Ptr', repmat(10, 1, 512));

status = calllib(libname, 'hp816x_convertQuestionableStatus_Q', session, QuestionableStatusInput, Message);

Message = strtrim(char(Message.Value));

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Convert Questionable Status function (hp816x_convertQuestionableStatus_Q) converts a questionable Status word to a message string describing the questionable event.

The questionable status word for all slots is retuned by the Module Status Array output of the Get Module Status function (hp816x_getModuleStatus_Q).

You must allocate a message buffer to assure that the array Message is connected to the Max Message Length output returned by the Get Module Status function (hp816x_getModuleStatus_Q). This allocates a size to the message buffer for the Message output.</Description>
            </Method>
            <Method>
               <Name>enabledisabledisplay</Name>
               <Location>MainframeSpecific</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function enabledisabledisplay(obj, Display)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_enableDisableDisplay', session, Display);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Enable-Disable Display function (hp816x_enableDisableDisplay) turns the display of the instrument On or Off.

 </Description>
            </Method>
            <Method>
               <Name>generatetrigger</Name>
               <Location>MainframeSpecific</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function generatetrigger(obj, TriggerAt)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_generateTrigger', session, TriggerAt);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Generate Trigger function (hp816x_generateTrigger) triggers the selected trigger node.</Description>
            </Method>
            <Method>
               <Name>getlockstate</Name>
               <Location>MainframeSpecific</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [SoftLock, RemoteInterlock] = getlockstate(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
SoftLock = libpointer('uint16Ptr', 0);
RemoteInterlock = libpointer('uint16Ptr', 0);

status = calllib(libname, 'hp816x_getLockState', session, SoftLock, RemoteInterlock);

SoftLock = double(SoftLock.Value);
RemoteInterlock = double(RemoteInterlock.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The function returns the lock  state of the mainframe. The function informs the user, if either a softlock or a remote interlock is active. If one lock or both are set, high power laser sources can not be turned on.</Description>
            </Method>
            <Method>
               <Name>getmodulestatusq</Name>
               <Location>MainframeSpecific</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [StatusSummary, ModuleStatusArray, MaxMessageLength] = getmodulestatusq(obj, ModuleStatusArray)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
StatusSummary = libpointer('uint16Ptr', 0);
ModuleStatusArray = libpointer('int32Ptr', ModuleStatusArray);
MaxMessageLength = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_getModuleStatus_Q', session, StatusSummary, ModuleStatusArray, MaxMessageLength);

StatusSummary = double(StatusSummary.Value);
ModuleStatusArray = double(ModuleStatusArray.Value);
MaxMessageLength = double(MaxMessageLength.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get Module Status function (hp816x_getModuleStatus_Q) checks the questionable status condition register of all modules inserted into the instrument. The questionable status condition is the current status of all modules. See your instrument's Programming Guide for information on the instrument's Status System.

Questionable status information is information about the following module errors:

if excessive power is set by the user,
if zeroing failed,
if temperature is out of range,
if laser protection is switched on,
if the module has not settled,
if the module is out of specifications,
if ARA is recommended
if the duty cycle is out of range.
if Beam Path Protection On or
the Precision range is suboptimal

REMARKS
You must assure that the Array Size is properly allocated.</Description>
            </Method>
            <Method>
               <Name>getslotinformationq</Name>
               <Location>MainframeSpecific</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [SlotInformation] = getslotinformationq(obj, ArraySize, SlotInformation)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
SlotInformation = libpointer('int32Ptr', SlotInformation);

status = calllib(libname, 'hp816x_getSlotInformation_Q', session, ArraySize, SlotInformation);

SlotInformation = double(SlotInformation.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get Slot Information function (hp816x_getSlotInformation_Q) returns information about installed modules. The Slot Information can be used to write applications that are independent of the physical location of the inserted modules. 

REMARKS
You must assure that the Array Size is properly allocated.</Description>
            </Method>
            <Method>
               <Name>lockunlockinstument</Name>
               <Location>MainframeSpecific</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function lockunlockinstument(obj, Softlock, Password)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Password = [double(Password) 0];

status = calllib(libname, 'hp816x_lockUnlockInstument', session, Softlock, Password);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Lock-Unlock Instrument function (hp816x_lockUnlockInstrument) locks or unlocks the software lock for high power source modules inserted in the mainframe.</Description>
            </Method>
            <Method>
               <Name>mainframeselftest</Name>
               <Location>MainframeSpecific</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [SelfTestResult, SelfTestMessage] = mainframeselftest(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
SelfTestResult = libpointer('int16Ptr', 0);
SelfTestMessage = libpointer('int8Ptr', repmat(10, 1, 512));

status = calllib(libname, 'hp816x_mainframeSelftest', session, SelfTestResult, SelfTestMessage);

SelfTestResult = double(SelfTestResult.Value);
SelfTestMessage = strtrim(char(SelfTestMessage.Value));

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Mainframe Self-Test function (hp816x_mainframeSelftest) makes the instrument perform a self-test on the mainframe and all slots. The final result is returned as Self-Test Message.

If the self-test fails, the instrument returns an error code as the Self-Test Result. Look up the *TST? command in your instrument's Programming Guide for an explanation of the Self-Test Result.

No further commands are allowed while the test is running. After the self-test the instrument is returned to the setting that was active at the time the self-test query was processed.</Description>
            </Method>
            <Method>
               <Name>moduleselftest</Name>
               <Location>MainframeSpecific</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Result, SelfTestMessage] = moduleselftest(obj, SlottoTest)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Result = libpointer('int16Ptr', 0);
SelfTestMessage = libpointer('int8Ptr', repmat(10, 1, 512));

status = calllib(libname, 'hp816x_moduleSelftest', session, SlottoTest, Result, SelfTestMessage);

Result = double(Result.Value);
SelfTestMessage = strtrim(char(SelfTestMessage.Value));

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Module Self-Test (hp816x_moduleSelftest) returns the latest selftest results for a module inserted in a given slot.

NOTE:
This command does not perform a selftest. Use the Mainframe Self-Test function (hp816x_mainframeSelftest) to make the instrument perform a self-test on the mainframe and all slots.</Description>
            </Method>
            <Method>
               <Name>preset</Name>
               <Location>MainframeSpecific</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function preset(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_preset', session);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Preset function (hp816x_preset) resets the instrument to its initial state. The parameters of the instrument and its modules are set to their default values.

This function is the same as pressing the preset hardkey on the instrument's front panel.

This function is also identical to the ":syst:preset" GPIB command. See your instrument's Programming Guide for information on GPIB commands.</Description>
            </Method>
            <Method>
               <Name>reset</Name>
               <Location>MainframeSpecific</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function reset(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_reset', session);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Reset function (hp816x_reset) resets the instrument and the GPIB bus to their initial state. The parameters of the instrument and its modules are set to their default values.

This function is identical to the "*RST" GPIB command. See your instrument's Programming Guide for information on GPIB commands.
 
</Description>
            </Method>
            <Method>
               <Name>revisionq</Name>
               <Location>MainframeSpecific</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [DriverRevision, FirmwareRevision] = revisionq(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
DriverRevision = libpointer('int8Ptr', repmat(10, 1, 512));
FirmwareRevision = libpointer('int8Ptr', repmat(10, 1, 512));

status = calllib(libname, 'hp816x_revision_Q', session, DriverRevision, FirmwareRevision);

DriverRevision = strtrim(char(DriverRevision.Value));
FirmwareRevision = strtrim(char(FirmwareRevision.Value));

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Revision Query function (hp816x_revision_Q) returns the revision number of the instrument driver and of the instrument firmware. </Description>
            </Method>
            <Method>
               <Name>revisionquery</Name>
               <Location>MainframeSpecific</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [DriverRevision, FirmwareRevision] = revisionquery(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
DriverRevision = libpointer('int8Ptr', repmat(10, 1, 512));
FirmwareRevision = libpointer('int8Ptr', repmat(10, 1, 512));

status = calllib(libname, 'hp816x_revision_query', session, DriverRevision, FirmwareRevision);

DriverRevision = strtrim(char(DriverRevision.Value));
FirmwareRevision = strtrim(char(FirmwareRevision.Value));

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Revision Query function (hp816x_revision_query) returns the revision number of the instrument driver and of the instrument firmware. </Description>
            </Method>
            <Method>
               <Name>selftest</Name>
               <Location>MainframeSpecific</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [SelfTestResult, SelfTestMessage] = selftest(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
SelfTestResult = libpointer('int16Ptr', 0);
SelfTestMessage = libpointer('int8Ptr', repmat(10, 1, 512));

status = calllib(libname, 'hp816x_self_test', session, SelfTestResult, SelfTestMessage);

SelfTestResult = double(SelfTestResult.Value);
SelfTestMessage = strtrim(char(SelfTestMessage.Value));

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Self-Test function (hp816x_self_test) makes the instrument perform a self-test on the mainframe and all slots. The final result is returned as Self-Test Message.

If the self-test fails, the instrument returns an error code as the Self-Test Result. Look up the *TST? command in your instrument's Programming Guide for an explanation of the Self-Test Result.</Description>
            </Method>
            <Method>
               <Name>standardtriggerconfiguration</Name>
               <Location>MainframeSpecific</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function standardtriggerconfiguration(obj, TriggerConfiguration, NodeAInputConfig, NodeBInputConfig, OutputMatrixConfiguration)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_standardTriggerConfiguration', session, TriggerConfiguration, NodeAInputConfig, NodeBInputConfig, OutputMatrixConfiguration);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Standard Trigger Configuration (hp816x_standardTriggerConfiguration) function configures the mainframe trigger system.</Description>
            </Method>
            <Method>
               <Name>standardtriggerconfigurationq</Name>
               <Location>MainframeSpecific</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [TriggerConfiguration, NodeAInputConfig, NodeBInputConfig, OutputMatrixConfiguration] = standardtriggerconfigurationq(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
TriggerConfiguration = libpointer('int32Ptr', 0);
NodeAInputConfig = libpointer('uint32Ptr', 0);
NodeBInputConfig = libpointer('uint32Ptr', 0);
OutputMatrixConfiguration = libpointer('uint32Ptr', 0);

status = calllib(libname, 'hp816x_standardTriggerConfiguration_Q', session, TriggerConfiguration, NodeAInputConfig, NodeBInputConfig, OutputMatrixConfiguration);

TriggerConfiguration = double(TriggerConfiguration.Value);
NodeAInputConfig = double(NodeAInputConfig.Value);
NodeBInputConfig = double(NodeBInputConfig.Value);
OutputMatrixConfiguration = double(OutputMatrixConfiguration.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description/>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>MainframeSpecificFunctionsCustomTrigger</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="MainframeSpecificFunctionsCustomTrigger1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>nodeinputconfiguration</Name>
               <Location>MainframeSpecificFunctionsCustomTrigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [NodeAInputConfiguration, NodeBInputConfiguration] = nodeinputconfiguration(obj, ConnectionFunctionNodeA, BNCTriggerConnector, NodeBTriggerOutput, Slot0, Slot1, Slot2, Slot3, Slot4, ConnectionFunctionNodeB, BNCTriggerConnector, NodeATriggerOutput, Slot0, Slot1, Slot2, Slot3, Slot4)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
NodeAInputConfiguration = libpointer('uint32Ptr', 0);
NodeBInputConfiguration = libpointer('uint32Ptr', 0);

status = calllib(libname, 'hp816x_nodeInputConfiguration', ConnectionFunctionNodeA, BNCTriggerConnector, NodeBTriggerOutput, Slot0, Slot1, Slot2, Slot3, Slot4, ConnectionFunctionNodeB, BNCTriggerConnector, NodeATriggerOutput, Slot0, Slot1, Slot2, Slot3, Slot4, NodeAInputConfiguration, NodeBInputConfiguration);

NodeAInputConfiguration = double(NodeAInputConfiguration.Value);
NodeBInputConfiguration = double(NodeBInputConfiguration.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Trigger Input Configuration function (hp816x_nodeInputConfiguration) helps you use the "Custom" Trigger Configuration of the Standard Trigger Configuration function (hp816x_standardTriggerConfiguration). 

The "Custom" configuration requires you to enter three 32-bit values as input parameters. This function calculates two of these 32-values, Node A Input Config and Node B Input Config. 

You should use the Outputs of this function as Inputs for the Standard Trigger Configuration function (hp816x_standardTriggerConfiguration).</Description>
            </Method>
            <Method>
               <Name>trigoutconfiguration</Name>
               <Location>MainframeSpecificFunctionsCustomTrigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [OutputMatrixConfiguration] = trigoutconfiguration(obj, NodeswitchedtoBNCOutput, Slot0, Slot1, Slot2, Slot3, Slot4)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
OutputMatrixConfiguration = libpointer('uint32Ptr', 0);

status = calllib(libname, 'hp816x_trigOutConfiguration', NodeswitchedtoBNCOutput, Slot0, Slot1, Slot2, Slot3, Slot4, OutputMatrixConfiguration);

OutputMatrixConfiguration = double(OutputMatrixConfiguration.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Trigger Output Configuration function (hp816x_nodeOutputConfiguration) helps you use the "Custom" Trigger Configuration of the Standard Trigger Configuration function (hp816x_standardTriggerConfiguration).

The "Custom" configuration requires you to enter three 32-bit values as input parameters. This function calculates one of these 32-values, Output Matrix Configuration.

You should use the Output of this function as an Input for the Standard Trigger Configuration function (hp816x_standardTriggerConfiguration).</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>PowerMeterModules</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="PowerMeterModules1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>getpwmaveragingtimeq</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [AveragingTime] = getpwmaveragingtimeq(obj, PWMSlot, ChannelNumber)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
AveragingTime = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_PWM_averagingTime_Q', session, PWMSlot, ChannelNumber, AveragingTime);

AveragingTime = double(AveragingTime.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get PWM Averaging Time (hp816x_get_PWM_averagingTime_Q) function returns the averaging time of a Power Meter.</Description>
            </Method>
            <Method>
               <Name>getpwmcalibrationq</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Calibration] = getpwmcalibrationq(obj, PWMSlot, ChannelNumber)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Calibration = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_PWM_calibration_Q', session, PWMSlot, ChannelNumber, Calibration);

Calibration = double(Calibration.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get PWM Calibration function (hp816x_get_PWM_calibration_Q) returns the calibration factor of your Power Meter in dBm. </Description>
            </Method>
            <Method>
               <Name>getpwmparametersq</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [RangeMode, PowerUnit, InternalTrigger, Wavelength, AveragingTime, PowerRange] = getpwmparametersq(obj, PWMSlot, ChannelNumber)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
RangeMode = libpointer('uint16Ptr', 0);
PowerUnit = libpointer('uint16Ptr', 0);
InternalTrigger = libpointer('uint16Ptr', 0);
Wavelength = libpointer('doublePtr', 0);
AveragingTime = libpointer('doublePtr', 0);
PowerRange = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_PWM_parameters_Q', session, PWMSlot, ChannelNumber, RangeMode, PowerUnit, InternalTrigger, Wavelength, AveragingTime, PowerRange);

RangeMode = double(RangeMode.Value);
PowerUnit = double(PowerUnit.Value);
InternalTrigger = double(InternalTrigger.Value);
Wavelength = double(Wavelength.Value);
AveragingTime = double(AveragingTime.Value);
PowerRange = double(PowerRange.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get PWM parameters function (hp816x_get_PWM_parameters_Q) returns the most important parameters for a sensor.</Description>
            </Method>
            <Method>
               <Name>getpwmpowerrangeq</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [RangeMode, PowerRange] = getpwmpowerrangeq(obj, PWMSlot, ChannelNumber)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
RangeMode = libpointer('uint16Ptr', 0);
PowerRange = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_PWM_powerRange_Q', session, PWMSlot, ChannelNumber, RangeMode, PowerRange);

RangeMode = double(RangeMode.Value);
PowerRange = double(PowerRange.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get PWM Range function (hp816x_get_PWM_powerRange_Q) returns the power range setting of a Power Meter.</Description>
            </Method>
            <Method>
               <Name>getpwmpowerunitq</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [PowerUnit] = getpwmpowerunitq(obj, PWMSlot, ChannelNumber)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
PowerUnit = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_get_PWM_powerUnit_Q', session, PWMSlot, ChannelNumber, PowerUnit);

PowerUnit = double(PowerUnit.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get PWM Power Unit function (hp816x_get_PWM_powerUnit_Q) returns the power units of a Power Meter. 
 </Description>
            </Method>
            <Method>
               <Name>getpwmreferencesourceq</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [MeasureMode, ReferenceSource, ReferenceSlot, ReferenceChannel] = getpwmreferencesourceq(obj, PWMSlot, ChannelNumber)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
MeasureMode = libpointer('int32Ptr', 0);
ReferenceSource = libpointer('int32Ptr', 0);
ReferenceSlot = libpointer('uint32Ptr', 0);
ReferenceChannel = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_get_PWM_referenceSource_Q', session, PWMSlot, ChannelNumber, MeasureMode, ReferenceSource, ReferenceSlot, ReferenceChannel);

MeasureMode = double(MeasureMode.Value);
ReferenceSource = double(ReferenceSource.Value);
ReferenceSlot = double(ReferenceSlot.Value);
ReferenceChannel = double(ReferenceChannel.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get PWM Reference Source function (hp816x_get_PWM_referenceSource) returns the reference control parameters.</Description>
            </Method>
            <Method>
               <Name>getpwmreferencevalueq</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [ReferenceMode, InternalReference, ReferenceChannel] = getpwmreferencevalueq(obj, PWMSlot, ChannelNumber)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
ReferenceMode = libpointer('int32Ptr', 0);
InternalReference = libpointer('doublePtr', 0);
ReferenceChannel = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_PWM_referenceValue_Q', session, PWMSlot, ChannelNumber, ReferenceMode, InternalReference, ReferenceChannel);

ReferenceMode = double(ReferenceMode.Value);
InternalReference = double(InternalReference.Value);
ReferenceChannel = double(ReferenceChannel.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get PWM Reference Value function (hp816x_get_PWM_referenceValue_Q) returns the current internal, external reference values and the reference mode.</Description>
            </Method>
            <Method>
               <Name>getpwmtriggerconfiguration</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [TriggerIn, TriggerOut] = getpwmtriggerconfiguration(obj, PWMSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
TriggerIn = libpointer('int32Ptr', 0);
TriggerOut = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_get_PWM_triggerConfiguration', session, PWMSlot, TriggerIn, TriggerOut);

TriggerIn = double(TriggerIn.Value);
TriggerOut = double(TriggerOut.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get PWM Trigger Configuration (hp816x_get_PWM_triggerConfiguration) function returns the input trigger handling configuration and the output trigger generation configuration for a Power Meter.</Description>
            </Method>
            <Method>
               <Name>getpwmwavelengthq</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [MinWavelength, MaxWavelength, CurrentWavelength] = getpwmwavelengthq(obj, PWMSlot, ChannelNumber)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
MinWavelength = libpointer('doublePtr', 0);
MaxWavelength = libpointer('doublePtr', 0);
CurrentWavelength = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_PWM_wavelength_Q', session, PWMSlot, ChannelNumber, MinWavelength, MaxWavelength, CurrentWavelength);

MinWavelength = double(MinWavelength.Value);
MaxWavelength = double(MaxWavelength.Value);
CurrentWavelength = double(CurrentWavelength.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get PWM Wavelength function (hp816x_get_PWM_wavelength_Q) returns the minimum, maximum, and current wavelength of a Power Meter. 

The responsivity of the Power Meter varies with wavelength. For accurate power measurement, you need to input the wavelength of the optical input.</Description>
            </Method>
            <Method>
               <Name>pwmdisplaytoreference</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function pwmdisplaytoreference(obj, PWMSlot, ChannelNumber)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_PWM_displayToReference', session, PWMSlot, ChannelNumber);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use the PWM Display to Reference function (hp816x_PWM_displayToReference) to choose the currently displayed power value as the new internal reference.</Description>
            </Method>
            <Method>
               <Name>pwmfetchvalue</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [MeasuredValue] = pwmfetchvalue(obj, PWMSlot, ChannelNumber)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
MeasuredValue = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_PWM_fetchValue', session, PWMSlot, ChannelNumber, MeasuredValue);

MeasuredValue = double(MeasuredValue.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Fetch PWM Value function (hp816x_PWM_fetchValue) immediately returns a power value without averaging power measurements over the averaging time period. 

REMARKS:
If this function is called more than once within an averaging cycle, the returned values will be identical.
</Description>
            </Method>
            <Method>
               <Name>pwmignoreerror</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function pwmignoreerror(obj, PWMSlot, ChannelNumber, IgnoreError, InstrumentErrorNumber)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_PWM_ignoreError', session, PWMSlot, ChannelNumber, IgnoreError, InstrumentErrorNumber);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use the Ignore Instrument Error function (hp816x_PWM_ignoreError) to trap a specific instrument error for a Power Meter. 


If the specified error occurs, the returned status of a call causing this error will be VI_SUCCESS.</Description>
            </Method>
            <Method>
               <Name>pwmreadall</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [NumberofChannels, Slots, Channels, Values] = pwmreadall(obj, Slots, Channels, Values)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
NumberofChannels = libpointer('uint32Ptr', 0);
Slots = libpointer('int32Ptr', Slots);
Channels = libpointer('int32Ptr', Channels);
Values = libpointer('doublePtr', Values);

status = calllib(libname, 'hp816x_PWM_readAll', session, NumberofChannels, Slots, Channels, Values);

NumberofChannels = double(NumberofChannels.Value);
Slots = double(Slots.Value);
Channels = double(Channels.Value);
Values = double(Values.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Read All PWM Values function (hp816x_PWM_readAll) forces the instrument to begin a measurement cycle. Power values are not returned until the averaging time required to read every powermeter channel hosted by the mainframe is complete. 

The returned information is stored in three arrays. Each element in the "Values" array (value[index]) was read from the powermeter channel identified by the correponding element in the "Slots" array (slot[index]) and "Channel" array (channel[index]).

Note: 
The caller of this function is responsible for allocating enough memory for the passed arrays. (The maximum array size is 34 for an Agilent 8166 mainframe) 

Every powermeter module read by this function must have firmware version 3.0 or higher.
</Description>
            </Method>
            <Method>
               <Name>pwmreadvalue</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [MeasuredValue] = pwmreadvalue(obj, PWMSlot, ChannelNumber)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
MeasuredValue = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_PWM_readValue', session, PWMSlot, ChannelNumber, MeasuredValue);

MeasuredValue = double(MeasuredValue.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Read PWM Value function (hp816x_PWM_readValue) forces the instrument to start a measurement cycle. The evaluated power value will not be returned, until the averaging time period is finished.</Description>
            </Method>
            <Method>
               <Name>pwmslavechannelcheck</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function pwmslavechannelcheck(obj, PWMSlot, SlaveChannelCheck)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_PWM_slaveChannelCheck', session, PWMSlot, SlaveChannelCheck);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Slave Channel Check function (hp816x_PWM_slaveChannelCheck) allows you to automatically correct parameters that are passed mistakenly to the slave channel of a dual Power Meter.

Some parameters for dual Power Meters can only be passed to the master channel, channel 1. The parameter affects the slave channel, channel 2. See your mainframe's programming guide for a table of GPIB commands that can only be configured for the master channel.

If Slave Channel Check is On, the driver generates a run-time error, if a command is passed mistakenly to the slave channel of a dual Power Meter.

If Slave Channel Check is Off, the driver corrects parameters that are passed mistakenly to the slave channel of a dual Power Meter. Off is the default.</Description>
            </Method>
            <Method>
               <Name>pwmzeroing</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [ZeroingResult] = pwmzeroing(obj, PWMSlot, ChannelNumber)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
ZeroingResult = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_PWM_zeroing', session, PWMSlot, ChannelNumber, ZeroingResult);

ZeroingResult = double(ZeroingResult.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The PWM Zeroing function (hp816x_PWM_zeroing) removes electrical offsets for one Power Meter. 

The instrument measures by converting optical power to electrical power, and then measuring electrical power. An electrical offset is power that is always present, even if there is no light at the input. If this offset is not removed, it will affect power measurement.</Description>
            </Method>
            <Method>
               <Name>pwmzeroingall</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [SummaryofZeroingAll] = pwmzeroingall(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
SummaryofZeroingAll = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_PWM_zeroingAll', session, SummaryofZeroingAll);

SummaryofZeroingAll = double(SummaryofZeroingAll.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The PWM Zeroing All function (hp816x_PWM_zeroingAll) removes electrical offsets for all Power Meter modules. 

The instrument measures by converting optical power to electrical power, and then measuring electrical power. An electrical offset is power that is always present, even if there is no light at the input. If this offset is not removed, it will affect power measurement.

NOTE:
Because zeroing is a time consuming operation, the timeout is
temporarily increased.

</Description>
            </Method>
            <Method>
               <Name>setpwmaveragingtime</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setpwmaveragingtime(obj, PWMSlot, ChannelNumber, AveragingTime)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_PWM_averagingTime', session, PWMSlot, ChannelNumber, AveragingTime);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set PWM Averaging Time function (hp816x_set_PWM_averagingTime) sets the averaging time of a Power Meter.</Description>
            </Method>
            <Method>
               <Name>setpwmcalibration</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setpwmcalibration(obj, PWMSlot, ChannelNumber, Calibration)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_PWM_calibration', session, PWMSlot, ChannelNumber, Calibration);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set PWM Calibration function (hp816x_set_PWM_calibration) sets the calibration factor of a Power Meter. 

This is a calibration offset that you can enter to compensate for external optical circuitry, for example, the Agilent 81022FF Integrating Sphere or a 3 dB coupler. This value is automatically subtracted from the input signal.
 </Description>
            </Method>
            <Method>
               <Name>setpwminternaltrigger</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setpwminternaltrigger(obj, PWMSlot, ChannelNumber, InternalTrigger)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_PWM_internalTrigger', session, PWMSlot, ChannelNumber, InternalTrigger);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set PWM Internal Trigger function (hp816x_set_PWM_internalTrigger) determine how the Power Meter starts measuring. </Description>
            </Method>
            <Method>
               <Name>setpwmparameters</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setpwmparameters(obj, PWMSlot, ChannelNumber, RangeMode, PowerUnit, InternalTrigger, Wavelength, AveragingTime, PowerRange)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_PWM_parameters', session, PWMSlot, ChannelNumber, RangeMode, PowerUnit, InternalTrigger, Wavelength, AveragingTime, PowerRange);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set PWM Parameters function (hp816x_set_PWM_parameters) sets the most important parameters for a sensor, preparing the instrument to start a measurement. 

If a value is not yet applied to the instrument and the Force Transaction function (hp816x_forceTransaction) is switched off, the new values will be set.</Description>
            </Method>
            <Method>
               <Name>setpwmpowerrange</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setpwmpowerrange(obj, PWMSlot, ChannelNumber, RangeMode, PowerRange)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_PWM_powerRange', session, PWMSlot, ChannelNumber, RangeMode, PowerRange);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set PWM Range function (hp816x_set_PWM_powerRange) sets the power range of a Power Meter. </Description>
            </Method>
            <Method>
               <Name>setpwmpowerunit</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setpwmpowerunit(obj, PWMSlot, ChannelNumber, PowerUnit)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_PWM_powerUnit', session, PWMSlot, ChannelNumber, PowerUnit);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The set PWM Power Unit function (hp816x_set_PWM_powerUnit) sets the power unit of a Power Meter.</Description>
            </Method>
            <Method>
               <Name>setpwmreferencesource</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setpwmreferencesource(obj, PWMSlot, ChannelNumber, MeasureMode, ReferenceSource, Slot, Channel)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_PWM_referenceSource', session, PWMSlot, ChannelNumber, MeasureMode, ReferenceSource, Slot, Channel);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set PWM Reference Source function (hp816x_set_PWM_referenceSource) sets the reference control parameters.

</Description>
            </Method>
            <Method>
               <Name>setpwmreferencevalue</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setpwmreferencevalue(obj, PWMSlot, ChannelNumber, InternalReference, ReferenceChannel)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_PWM_referenceValue', session, PWMSlot, ChannelNumber, InternalReference, ReferenceChannel);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set PWM Reference Value function (hp816x_set_PWM_referenceValue) sets the internal reference value and the reference channel.

These two reference values are independent and have separate memory locations.</Description>
            </Method>
            <Method>
               <Name>setpwmtriggerconfiguration</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setpwmtriggerconfiguration(obj, PWMSlot, TriggerIn, TriggerOut)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_PWM_triggerConfiguration', session, PWMSlot, TriggerIn, TriggerOut);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set PWM Trigger Configuration (hp816x_set_PWM_triggerConfiguration) function configures input trigger handling and trigger output generation.</Description>
            </Method>
            <Method>
               <Name>setpwmwavelength</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setpwmwavelength(obj, PWMSlot, ChannelNumber, Wavelength)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_PWM_wavelength', session, PWMSlot, ChannelNumber, Wavelength);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set PWM Wavelength function (hp816x_set_PWM_wavelength) sets the wavelength of a sensor. </Description>
            </Method>
            <Method>
               <Name>startpwminternaltrigger</Name>
               <Location>PowerMeterModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function startpwminternaltrigger(obj, PWMSlot, ChannelNumber)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_start_PWM_internalTrigger', session, PWMSlot, ChannelNumber);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Start PWM Internal Trigger function (hp816x_start_PWM_internalTrigger) starts a Power Meter measurement cycle. 

If you have previously chosen Continuous Triggering mode, see the Set PWM Internal Trigger function, the function chooses Immediate Triggering mode automatically. You need to use the Start PWM Trigger function to start another Power Meter measurement cycle.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>PowerMeterModulesMultiWavelengthCalibration</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="PowerMeterModulesMultiWavelengthCalibration1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>getwlresptblsizeex</Name>
               <Location>PowerMeterModulesMultiWavelengthCalibration</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Size, CSVSize] = getwlresptblsizeex(obj, Slot, Channel)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Size = libpointer('uint32Ptr', 0);
CSVSize = libpointer('uint32Ptr', 0);

status = calllib(libname, 'hp816x_getWlRespTblSizeEx', session, Slot, Channel, Size, CSVSize);

Size = double(Size.Value);
CSVSize = double(CSVSize.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function returns the size of the wavelength response table, for different formats.</Description>
            </Method>
            <Method>
               <Name>readwlreptblcsvex</Name>
               <Location>PowerMeterModulesMultiWavelengthCalibration</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [CSVList] = readwlreptblcsvex(obj, Slot, Channel)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
CSVList = libpointer('int8Ptr', repmat(10, 1, 512));

status = calllib(libname, 'hp816x_readWlRepTblCSV_Ex', session, Slot, Channel, CSVList);

CSVList = strtrim(char(CSVList.Value));

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function returns the calibrated wavelength response table as comma separated values. The size of the table can be queried calling the function Get Wavelength Rep. Tbl. Size.</Description>
            </Method>
            <Method>
               <Name>readwlresptableex</Name>
               <Location>PowerMeterModulesMultiWavelengthCalibration</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Wavelength, ResponseFactor] = readwlresptableex(obj, Slot, Channel, Wavelength, ResponseFactor)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Wavelength = libpointer('doublePtr', Wavelength);
ResponseFactor = libpointer('doublePtr', ResponseFactor);

status = calllib(libname, 'hp816x_readWlRespTableEx', session, Slot, Channel, Wavelength, ResponseFactor);

Wavelength = double(Wavelength.Value);
ResponseFactor = double(ResponseFactor.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function returns the calibrated wavelength response table . The size of the table can be queried calling the function Get Wavelength Rep. Tbl. Size.</Description>
            </Method>
            <Method>
               <Name>spectralcalibrationex</Name>
               <Location>PowerMeterModulesMultiWavelengthCalibration</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [WavelengthResult, ErrorDiagnose] = spectralcalibrationex(obj, Slot, Channel, SizeofSpectrum, Wavelength, Power)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
WavelengthResult = libpointer('doublePtr', 0);
ErrorDiagnose = libpointer('int8Ptr', repmat(10, 1, 512));

status = calllib(libname, 'hp816x_spectralCalibrationEx', session, Slot, Channel, SizeofSpectrum, Wavelength, Power, WavelengthResult, ErrorDiagnose);

WavelengthResult = double(WavelengthResult.Value);
ErrorDiagnose = strtrim(char(ErrorDiagnose.Value));

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function calculates and sets the wavelength of an powermeter module.
For this calculation the spectrum of the used laser source is needed.
 </Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>PowerMeterModulesPWMDataAcquisition</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="PowerMeterModulesPWMDataAcquisition1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>getpwmloggingresultsq</Name>
               <Location>PowerMeterModulesPWMDataAcquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [LoggingStatus, LoggingResult] = getpwmloggingresultsq(obj, PWMSlot, ChannelNumber, WaitforCompletion, ResultUnit, LoggingResult)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
LoggingStatus = libpointer('uint16Ptr', 0);
LoggingResult = libpointer('doublePtr', LoggingResult);

status = calllib(libname, 'hp816x_get_PWM_loggingResults_Q', session, PWMSlot, ChannelNumber, WaitforCompletion, ResultUnit, LoggingStatus, LoggingResult);

LoggingStatus = double(LoggingStatus.Value);
LoggingResult = double(LoggingResult.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get PWM Logging Results function (hp816x_get_PWM_loggingResults_Q) returns the result of a previously started logging operation. 

NOTE:
The Wait for Completion control should only be set to Yes if the application is thoroughly tested because using this control may result in an infinite loop that blocks the calling function.

Also, if the function detects that logging is finished, the logging operation stops automatically.
</Description>
            </Method>
            <Method>
               <Name>getpwmminmaxresultsq</Name>
               <Location>PowerMeterModulesPWMDataAcquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Minimum, Maximum, Current] = getpwmminmaxresultsq(obj, PWMSlot, ChannelNumber)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Minimum = libpointer('doublePtr', 0);
Maximum = libpointer('doublePtr', 0);
Current = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_PWM_minMaxResults_Q', session, PWMSlot, ChannelNumber, Minimum, Maximum, Current);

Minimum = double(Minimum.Value);
Maximum = double(Maximum.Value);
Current = double(Current.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get PWM MinMax function (hp816x_get_PWM_minMax) returns the minimum, maximum and current values of a previously started MinMax operation. </Description>
            </Method>
            <Method>
               <Name>getpwmstabilityresultsq</Name>
               <Location>PowerMeterModulesPWMDataAcquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [StabilityStatus, StabilityResult] = getpwmstabilityresultsq(obj, PWMSlot, ChannelNumber, WaitforCompletion, ResultUnit, StabilityResult)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
StabilityStatus = libpointer('uint16Ptr', 0);
StabilityResult = libpointer('doublePtr', StabilityResult);

status = calllib(libname, 'hp816x_get_PWM_stabilityResults_Q', session, PWMSlot, ChannelNumber, WaitforCompletion, ResultUnit, StabilityStatus, StabilityResult);

StabilityStatus = double(StabilityStatus.Value);
StabilityResult = double(StabilityResult.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get PWM Stability Result function (hp816x_get_PWM_stabilityResults_Q) returns the result of a previously started stability operation. 

REMARK
The Wait for Completion control should only be set to Yes if the application is thoroughly tested because using this control may result in an infinite loop that blocks the calling function.

Also, if the function detects that logging is finished, the stability operation stops automatically.
</Description>
            </Method>
            <Method>
               <Name>pwmfunctionstop</Name>
               <Location>PowerMeterModulesPWMDataAcquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function pwmfunctionstop(obj, PWMSlot, ChannelNumber)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_PWM_functionStop', session, PWMSlot, ChannelNumber);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Stop PWM Function function (hp816x_PWM_functionStop) stops 
(aborts) any activated logging, stability or Min Max data aquistion operation. </Description>
            </Method>
            <Method>
               <Name>setpwmlogging</Name>
               <Location>PowerMeterModulesPWMDataAcquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [EstimatedTimeout] = setpwmlogging(obj, PWMSlot, ChannelNumber, AveragingTime, DataPoints)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
EstimatedTimeout = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_set_PWM_logging', session, PWMSlot, ChannelNumber, AveragingTime, DataPoints, EstimatedTimeout);

EstimatedTimeout = double(EstimatedTimeout.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set PWM Loggging function (hp816x_set_PWM_logging) sets the parameters for a logging operation and starts the logging.</Description>
            </Method>
            <Method>
               <Name>setpwmminmax</Name>
               <Location>PowerMeterModulesPWMDataAcquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [EstimatedTime] = setpwmminmax(obj, PWMSlot, ChannelNumber, MinMaxMode, DataPoints)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
EstimatedTime = libpointer('uint32Ptr', 0);

status = calllib(libname, 'hp816x_set_PWM_minMax', session, PWMSlot, ChannelNumber, MinMaxMode, DataPoints, EstimatedTime);

EstimatedTime = double(EstimatedTime.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set PWM MinMax function (hp816x_set_PWM_minMax) sets the parameters for a MinMax logging operation.
 
A MinMax logging operation is active as long as it is not explicitly stopped. Before you start a different Power Meter data acquisition function or different MinMax logging operation, you must call the Stop PWM Function function.

</Description>
            </Method>
            <Method>
               <Name>setpwmstability</Name>
               <Location>PowerMeterModulesPWMDataAcquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [EstimatedResults] = setpwmstability(obj, PWMSlot, ChannelNumber, AveragingTime, DelayTime, TotalTime)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
EstimatedResults = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_set_PWM_stability', session, PWMSlot, ChannelNumber, AveragingTime, DelayTime, TotalTime, EstimatedResults);

EstimatedResults = double(EstimatedResults.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set PWM Stability function (hp816x_set_PWM_stability) sets up a stability operation and starts the data acquisition.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>ReturnLossModules</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="ReturnLossModules1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>calibraterlm</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function calibraterlm(obj, RLMSlot, Calibrate)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_calibrate_RLM', session, RLMSlot, Calibrate);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Calibrate RLM function (hp816x_calibrate_RLM) allows you to set the Reflection Reference calibration values and the Termination Reference calibration values. You may set calibration values specific to your setup or choose the factory-set calibration values.

Calibration helps to eliminate the affect of wavelength dependencies, coupler directivity, insertion losses, backscattering, and other non-ideal system characteristics.

Performing a Reflection Reference calibration and a Termination Reference calibration will help you perform more accurate return loss measurements than if you use the factory-set calibration values. If you wish to perform a calibration, set up your instrumentation as explained in the mainframe's User's Guide and then call this function.
 </Description>
            </Method>
            <Method>
               <Name>enablerlmsweep</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function enablerlmsweep(obj, EnableRLMLambdaSweep)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_enable_RLM_sweep', session, EnableRLMLambdaSweep);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Enable RLM Lambda Sweep function (hp816x_enable_RLM_sweep) includes or excludes all Return Loss modules from a lambda scan operation.

A Return Loss module included in a lambda scan appears in the channel list as if it were a dual-channel power meter whose first channel addresses the power measured at its power diode, and whose second channel addresses the power measured at its monitor diode.

For example, if slot 1 is occupied by a single-channel power meter, and slot 2 by a Return Loss module:

 - channel 0 addresses the power meter's power diode,
 - channel 1 addresses the Return Loss module's power diode,
 - channel 3 addresses the Return Loss module's monitor diode.



 
</Description>
            </Method>
            <Method>
               <Name>getrlmaveragingtimeq</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [AveragingTime] = getrlmaveragingtimeq(obj, RLMSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
AveragingTime = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_RLM_averagingTime_Q', session, RLMSlot, AveragingTime);

AveragingTime = double(AveragingTime.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get RLM Averaging Time (hp816x_get_RLM_averagingTime_Q) function returns the averaging time of a Return Loss module.</Description>
            </Method>
            <Method>
               <Name>getrlmfpdeltaq</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [FrontPanelDelta] = getrlmfpdeltaq(obj, RLMSlot, LaserSource)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
FrontPanelDelta = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_RLM_FPDelta_Q', session, RLMSlot, LaserSource, FrontPanelDelta);

FrontPanelDelta = double(FrontPanelDelta.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get RLM Front Panel Delta function (hp816x_get_RLM_FPDelta_Q) returns the loss variation value due to the front panel connector.
</Description>
            </Method>
            <Method>
               <Name>getrlmparametersq</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [InternalTrigger, Wavelength, AveragingTime, LaserSource, LaserState] = getrlmparametersq(obj, RLMSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
InternalTrigger = libpointer('uint16Ptr', 0);
Wavelength = libpointer('doublePtr', 0);
AveragingTime = libpointer('doublePtr', 0);
LaserSource = libpointer('int32Ptr', 0);
LaserState = libpointer('uint16Ptr', 0);

status = calllib(libname, 'hp816x_get_RLM_parameters_Q', session, RLMSlot, InternalTrigger, Wavelength, AveragingTime, LaserSource, LaserState);

InternalTrigger = double(InternalTrigger.Value);
Wavelength = double(Wavelength.Value);
AveragingTime = double(AveragingTime.Value);
LaserSource = double(LaserSource.Value);
LaserState = double(LaserState.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get RLM parameters function (hp816x_get_RLM_parameters_Q) returns the most important parameters for a Return Loss module.</Description>
            </Method>
            <Method>
               <Name>getrlmpowerrangeq</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [RangeMode, PowerRange, PowerRangeSecondSensor] = getrlmpowerrangeq(obj, RLMSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
RangeMode = libpointer('uint16Ptr', 0);
PowerRange = libpointer('doublePtr', 0);
PowerRangeSecondSensor = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_RLM_powerRange_Q', session, RLMSlot, RangeMode, PowerRange, PowerRangeSecondSensor);

RangeMode = double(RangeMode.Value);
PowerRange = double(PowerRange.Value);
PowerRangeSecondSensor = double(PowerRangeSecondSensor.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get RLM Range function (hp816x_get_RLM_powerRange_Q) returns the power range setting of a Return Loss module.</Description>
            </Method>
            <Method>
               <Name>getrlmrlreferenceq</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [ReturnLossReference] = getrlmrlreferenceq(obj, RLMSlot, LaserSource)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
ReturnLossReference = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_RLM_rlReference_Q', session, RLMSlot, LaserSource, ReturnLossReference);

ReturnLossReference = double(ReturnLossReference.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get RLM Return Loss Reference function (hp816x_get_RLM_rlReference_Q) returns the return loss reference for a Return Loss module.</Description>
            </Method>
            <Method>
               <Name>getrlmwavelengthq</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [MinWavelength, MaxWavelength, DefaultWavelength, CurrentWavelength] = getrlmwavelengthq(obj, RLMSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
MinWavelength = libpointer('doublePtr', 0);
MaxWavelength = libpointer('doublePtr', 0);
DefaultWavelength = libpointer('doublePtr', 0);
CurrentWavelength = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_RLM_wavelength_Q', session, RLMSlot, MinWavelength, MaxWavelength, DefaultWavelength, CurrentWavelength);

MinWavelength = double(MinWavelength.Value);
MaxWavelength = double(MaxWavelength.Value);
DefaultWavelength = double(DefaultWavelength.Value);
CurrentWavelength = double(CurrentWavelength.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get RLM Wavelength function (hp816x_get_RLM_wavelength_Q) returns the minimum, maximum, and current wavelength of a Return Loss module. 

The responsivity of the Power Sensor varies with wavelength. For accurate power measurement, you need to input the wavelength of the optical input.</Description>
            </Method>
            <Method>
               <Name>rlmfetchreturnloss</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [ReturnLoss] = rlmfetchreturnloss(obj, RLMSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
ReturnLoss = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_RLM_fetchReturnLoss', session, RLMSlot, ReturnLoss);

ReturnLoss = double(ReturnLoss.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Fetch RLM Return Loss function (hp816x_RLM_fetchReturnLoss) immediately returns a return loss value without averaging return loss measurements over the averaging time period.

REMARKS: If this function is called more than once within an averaging cycle, the returned values will be identical.</Description>
            </Method>
            <Method>
               <Name>rlmfetchvalue</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [PowerValue] = rlmfetchvalue(obj, RLMSlot, MonitorDiode)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
PowerValue = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_RLM_fetchValue', session, RLMSlot, MonitorDiode, PowerValue);

PowerValue = double(PowerValue.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Fetch RLM Power Value function (hp816x_RLM_fetchValue) immediately returns a power value for either the internal monitor diode, or the return loss diode, without averaging power measurements over the averaging time period. 

REMARKS: If this function is called more than once within an averaging cycle, the returned values will be identical.
</Description>
            </Method>
            <Method>
               <Name>rlmreadreturnloss</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [ReturnLoss] = rlmreadreturnloss(obj, RLMSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
ReturnLoss = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_RLM_readReturnLoss', session, RLMSlot, ReturnLoss);

ReturnLoss = double(ReturnLoss.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Read RLM Return Loss function (hp816x_RLM_readReturnLoss) forces the instrument to start a measurement cycle. The evaluated return loss value will not be returned, until the averaging time period is finished.</Description>
            </Method>
            <Method>
               <Name>rlmreadvalue</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [PowerValue] = rlmreadvalue(obj, RLMSlot, MonitorDiode)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
PowerValue = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_RLM_readValue', session, RLMSlot, MonitorDiode, PowerValue);

PowerValue = double(PowerValue.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Read RLM Power Value function (hp816x_RLM_readValue) forces the instrument to start a measurement cycle. The Power Value will not be returned until the averaging time period is finished. You may choose whether you want to read a power value for the internal monitor diode, or for the return loss diode. 
</Description>
            </Method>
            <Method>
               <Name>rlmzeroing</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [ZeroingResult] = rlmzeroing(obj, RLMSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
ZeroingResult = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_RLM_zeroing', session, RLMSlot, ZeroingResult);

ZeroingResult = double(ZeroingResult.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The RLM Zeroing function (hp816x_RLM_zeroing) removes electrical offsets for one Return Loss module. 

The instrument measures by converting optical power to electrical power, and then measuring electrical power. An electrical offset is power that is always present, even if there is no light at the input. If this offset is not removed, it will affect power measurement.</Description>
            </Method>
            <Method>
               <Name>rlmzeroingall</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [SummaryofZeroingAll] = rlmzeroingall(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
SummaryofZeroingAll = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_RLM_zeroingAll', session, SummaryofZeroingAll);

SummaryofZeroingAll = double(SummaryofZeroingAll.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The RLM Zeroing All function (hp816x_RLM_zeroingAll) removes electrical offsets for all Return Loss modules and Power Meter modules and Power Meter modules. 

The instrument measures by converting optical power to electrical power, and then measuring electrical power. An electrical offset is power that is always present, even if there is no light at the input. If this offset is not removed, it will affect power measurement.

NOTE:
Because zeroing is a time consuming operation, the timeout is
temporarily increased.</Description>
            </Method>
            <Method>
               <Name>setrlmaveragingtime</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setrlmaveragingtime(obj, RLMSlot, AveragingTime)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_RLM_averagingTime', session, RLMSlot, AveragingTime);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set RLM Averaging Time function (hp816x_set_RLM_averagingTime) sets the averaging time of a Return Loss module.</Description>
            </Method>
            <Method>
               <Name>setrlmfpdelta</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setrlmfpdelta(obj, RLMSlot, LaserSource, FrontPanelDelta)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_RLM_FPDelta', session, RLMSlot, LaserSource, FrontPanelDelta);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set RLM Front Panel Delta function (hp816x_set_RLM_FPDelta) sets the loss variation value due to the front panel connector.

Follow the instructions in the User's Guide to measure this value.</Description>
            </Method>
            <Method>
               <Name>setrlminternaltrigger</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setrlminternaltrigger(obj, RLMSlot, InternalTrigger)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_RLM_internalTrigger', session, RLMSlot, InternalTrigger);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set RLM Internal Trigger function (hp816x_set_RLM_internalTrigger) determines how the Return Loss module starts measuring. </Description>
            </Method>
            <Method>
               <Name>setrlmparameters</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setrlmparameters(obj, RLMSlot, InternalTrigger, Wavelength, AveragingTime, LaserSource, LaserState)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_RLM_parameters', session, RLMSlot, InternalTrigger, Wavelength, AveragingTime, LaserSource, LaserState);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set RLM Parameters function (hp816x_set_RLM_parameters) sets the most important parameters for a Return Loss module, preparing the instrument to start a measurement. 

If a value is not yet applied to the instrument and the Force Transaction function (hp816x_forceTransaction) is switched off, the new values will be set.</Description>
            </Method>
            <Method>
               <Name>setrlmpowerrange</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setrlmpowerrange(obj, RLMSlot, RangeMode, PowerRange, PowerRangeSecondSensor)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_RLM_powerRange', session, RLMSlot, RangeMode, PowerRange, PowerRangeSecondSensor);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set RLM Range function (hp816x_set_RLM_powerRange) sets the power range of a Return Loss module. </Description>
            </Method>
            <Method>
               <Name>setrlmrlreference</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setrlmrlreference(obj, RLMSlot, LaserSource, ReturnLossReference)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_RLM_rlReference', session, RLMSlot, LaserSource, ReturnLossReference);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set RLM Return Loss Reference function (hp816x_set_RLM_rlReference) sets the return loss reference for a Return Loss module.</Description>
            </Method>
            <Method>
               <Name>setrlmtriggerconfiguration</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setrlmtriggerconfiguration(obj, RLMSlot, TriggerIn, TriggerOut)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_RLM_triggerConfiguration', session, RLMSlot, TriggerIn, TriggerOut);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set RLM Trigger Configuration (hp816x_set_RLM_triggerConfiguration) function configures input trigger handling and trigger output generation.</Description>
            </Method>
            <Method>
               <Name>setrlmwavelength</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setrlmwavelength(obj, RLMSlot, Wavelength)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_RLM_wavelength', session, RLMSlot, Wavelength);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set RLM Wavelength function (hp816x_set_RLM_wavelength) sets the wavelength of a Return Loss module.</Description>
            </Method>
            <Method>
               <Name>startrlminternaltrigger</Name>
               <Location>ReturnLossModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function startrlminternaltrigger(obj, RLMSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_start_RLM_internalTrigger', session, RLMSlot);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Start RLM Trigger function (hp816x_start_RLM_internalTrigger) starts a Return Loss measurement cycle. 

If you have precviously chosen Continuous Triggering mode, see the Set RLM Internal Trigger function, the function chooses Immediate Triggering mode automatically. You need to use the Start RLM Trigger function to start another Return Loss measurement cycle.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>ReturnLossModulesAdvanced</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="ReturnLossModulesAdvanced1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>calculaterl</Name>
               <Location>ReturnLossModulesAdvanced</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [ReturnLoss] = calculaterl(obj, RLMSlot, Mref, Mpara, Pref, Ppara, Mdut, Pdut, FrontPanelDelta)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
ReturnLoss = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_calculate_RL', session, RLMSlot, Mref, Mpara, Pref, Ppara, Mdut, Pdut, FrontPanelDelta, ReturnLoss);

ReturnLoss = double(ReturnLoss.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Calculate Return loss function (hp816x_calculate_RL) returns the Return Loss and the Return Loss of the DUT.

This function is intended to be used in more complex test set-ups. Use this function in combination with the following functions:

the Calibrate RLM function (hp816x_calibrate_RLM),

the Get Front Panel Delta function (hp816x_get_RLM_FPDelta_Q), 

the Get RLM Reflectance Values function (hp816x_get_RLM_reflectanceValues_Q),

the Get RLM Termination Values function (hp816x_get_RLM_terminationValues_Q), and 

the Get RLM DUT Values function (hp816x_get_RLM_dutValues_Q).

The last four functions return the input values that enable this function to calculate the Return Loss .</Description>
            </Method>
            <Method>
               <Name>getrlmdutvaluesq</Name>
               <Location>ReturnLossModulesAdvanced</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Mdut, Pdut] = getrlmdutvaluesq(obj, RLMSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Mdut = libpointer('doublePtr', 0);
Pdut = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_RLM_dutValues_Q', session, RLMSlot, Mdut, Pdut);

Mdut = double(Mdut.Value);
Pdut = double(Pdut.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get RLM DUT Values function (hp816x_get_RLM_dutValues_Q) reads the power values at the internal monitor and power diode. Set up your instrumentation to measure the Return Loss of the DUT as explained in the mainframe's User's Guide and then call this function.</Description>
            </Method>
            <Method>
               <Name>getrlmreflectancevaluesq</Name>
               <Location>ReturnLossModulesAdvanced</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Mref, Pref] = getrlmreflectancevaluesq(obj, RLMSlot, LaserSource)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Mref = libpointer('doublePtr', 0);
Pref = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_RLM_reflectanceValues_Q', session, RLMSlot, LaserSource, Mref, Pref);

Mref = double(Mref.Value);
Pref = double(Pref.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get RLM  Reflectance Values function (get_RLM_reflectanceValues_Q) returns Reflection Reference calibration values. These calibration values are required to calculate the return loss. 

If you wish to perform a calibration, set up your instrumentation for a Reflection Reference calibration as explained in the mainframe's User's Guide and then call the Calibrate RLM function (hp816x_calibrate_RLM).

You can also use the Calibrate RLM function (hp816x_calibrate_RLM) to choose factory-set calibration values.</Description>
            </Method>
            <Method>
               <Name>getrlmterminationvaluesq</Name>
               <Location>ReturnLossModulesAdvanced</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Mpara, Ppara] = getrlmterminationvaluesq(obj, RLMSlot, LaserSource)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Mpara = libpointer('doublePtr', 0);
Ppara = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_RLM_terminationValues_Q', session, RLMSlot, LaserSource, Mpara, Ppara);

Mpara = double(Mpara.Value);
Ppara = double(Ppara.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get RLM Termination Values function (get_RLM_terminationValues_Q) returns Termination Reference calibration values. These calibration values are required to calculate the return loss. 

If you wish to perform a calibration, set up your instrumentation for a Termination Reference calibration as explained in the mainframe's User's Guide and then call the Calibrate RLM function (hp816x_calibrate_RLM).

You can also use the Calibrate RLM function (hp816x_calibrate_RLM) to choose factory-set calibration values.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>ReturnLossModulesOptionalLaserSourceControl</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="ReturnLossModulesOptionalLaserSourceControl1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>getrlmlasersourceparametersq</Name>
               <Location>ReturnLossModulesOptionalLaserSourceControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [LaserSource, LaserState] = getrlmlasersourceparametersq(obj, RLMSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
LaserSource = libpointer('int32Ptr', 0);
LaserState = libpointer('uint16Ptr', 0);

status = calllib(libname, 'hp816x_get_RLM_laserSourceParameters_Q', session, RLMSlot, LaserSource, LaserState);

LaserSource = double(LaserSource.Value);
LaserState = double(LaserState.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set RLM Laser Source Parameters function (hp816x_set_RLM_laserSourceParameters) returns all parameters for a Return Loss module internal Laser Source.

In case of a single frequency Laser Source, the inputs for the lower source will be used.</Description>
            </Method>
            <Method>
               <Name>getrlmlaserstateq</Name>
               <Location>ReturnLossModulesOptionalLaserSourceControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [LaserState] = getrlmlaserstateq(obj, RLMSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
LaserState = libpointer('uint16Ptr', 0);

status = calllib(libname, 'hp816x_get_RLM_laserState_Q', session, RLMSlot, LaserState);

LaserState = double(LaserState.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get RLM Laser State function (hp816x_get_RLM_laserState) turns the laser on or off.</Description>
            </Method>
            <Method>
               <Name>getrlmmodulationstateq</Name>
               <Location>ReturnLossModulesOptionalLaserSourceControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [LowFrequencyControl] = getrlmmodulationstateq(obj, RLMSlot, LaserSource)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
LowFrequencyControl = libpointer('uint16Ptr', 0);

status = calllib(libname, 'hp816x_get_RLM_modulationState_Q', session, RLMSlot, LaserSource, LowFrequencyControl);

LowFrequencyControl = double(LowFrequencyControl.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get RLM Modulation function (hp816x_get_RLM_modulationState_Q) returns the internal modulation state of a laser source that is built into a Return Loss module. 

Internal Modulation is described in your instrument's User's Guide. </Description>
            </Method>
            <Method>
               <Name>getrlmsrcwavelengthq</Name>
               <Location>ReturnLossModulesOptionalLaserSourceControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [WavelengthLowerSource, WavelengthUpperSource] = getrlmsrcwavelengthq(obj, RLMSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
WavelengthLowerSource = libpointer('doublePtr', 0);
WavelengthUpperSource = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_RLM_srcWavelength_Q', session, RLMSlot, WavelengthLowerSource, WavelengthUpperSource);

WavelengthLowerSource = double(WavelengthLowerSource.Value);
WavelengthUpperSource = double(WavelengthUpperSource.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get RLM Source Wavelength function (hp816x_get_RLM_srcWavelength) returns the wavelength of a laser source that is built into a Return Loss module. 
</Description>
            </Method>
            <Method>
               <Name>setrlmlasersourceparameters</Name>
               <Location>ReturnLossModulesOptionalLaserSourceControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setrlmlasersourceparameters(obj, RLMSlot, LaserSource, TurnLaser)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_RLM_laserSourceParameters', session, RLMSlot, LaserSource, TurnLaser);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set RLM Laser Source Parameters function (hp816x_set_RLM_laserSourceParameters) sets all parameters for a Return Loss module with an internal Laser Source.

In case of a single frequency Laser Source, the inputs for the lower source will be used.</Description>
            </Method>
            <Method>
               <Name>setrlmlaserstate</Name>
               <Location>ReturnLossModulesOptionalLaserSourceControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setrlmlaserstate(obj, RLMSlot, LaserState)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_RLM_laserState', session, RLMSlot, LaserState);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set RLM Laser State function (hp816x_set_RLM_laserState) turns the laser on or off.</Description>
            </Method>
            <Method>
               <Name>setrlmmodulationstate</Name>
               <Location>ReturnLossModulesOptionalLaserSourceControl</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setrlmmodulationstate(obj, RLMSlot, LaserSource, LowFrequencyControl)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_RLM_modulationState', session, RLMSlot, LaserSource, LowFrequencyControl);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set RLM Modulation State function (hp816x_set_RLM_modulationState) adjusts the internal modulation of a laser source that is built into a Return Loss module. 

Internal Modulation is described in your instrument's User's Guide.
</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>ReturnLossModulesRLMDataAcquisition</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="ReturnLossModulesRLMDataAcquisition1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>getrlmloggingresultsq</Name>
               <Location>ReturnLossModulesRLMDataAcquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [LoggingStatus, LoggingResult] = getrlmloggingresultsq(obj, RLMSlot, WaitforCompletion, ResultUnit, MonitiorDiode, LoggingResult)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
LoggingStatus = libpointer('uint16Ptr', 0);
LoggingResult = libpointer('doublePtr', LoggingResult);

status = calllib(libname, 'hp816x_get_RLM_loggingResults_Q', session, RLMSlot, WaitforCompletion, ResultUnit, MonitiorDiode, LoggingStatus, LoggingResult);

LoggingStatus = double(LoggingStatus.Value);
LoggingResult = double(LoggingResult.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get RLM Logging Results function (hp816x_get_RLM_loggingResults_Q) returns the result of a previously started logging operation. 

NOTE:
The Wait for Completion control should only be set to Yes if the application is thoroughly tested because using this control may result in an infinite loop that blocks the calling function.

Also, if the function detects that logging is finished, the logging operation stops automatically.</Description>
            </Method>
            <Method>
               <Name>getrlmminmaxresultsq</Name>
               <Location>ReturnLossModulesRLMDataAcquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Minimum, Maximum, Current] = getrlmminmaxresultsq(obj, RLMSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Minimum = libpointer('doublePtr', 0);
Maximum = libpointer('doublePtr', 0);
Current = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_RLM_minMaxResults_Q', session, RLMSlot, Minimum, Maximum, Current);

Minimum = double(Minimum.Value);
Maximum = double(Maximum.Value);
Current = double(Current.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get RLM MinMax Results function (hp816x_get_RLM_minMaxResults_Q) returns the minimum, maximum and current values of a previously started MinMax operation. </Description>
            </Method>
            <Method>
               <Name>getrlmstabilityresultsq</Name>
               <Location>ReturnLossModulesRLMDataAcquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [StabilityStatus, StabilityResult] = getrlmstabilityresultsq(obj, RLMSlot, WaitforCompletion, ResultUnit, StabilityResult)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
StabilityStatus = libpointer('uint16Ptr', 0);
StabilityResult = libpointer('doublePtr', StabilityResult);

status = calllib(libname, 'hp816x_get_RLM_stabilityResults_Q', session, RLMSlot, WaitforCompletion, ResultUnit, StabilityStatus, StabilityResult);

StabilityStatus = double(StabilityStatus.Value);
StabilityResult = double(StabilityResult.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get RLM Stability Results function (hp816x_get_RLM_stabilityResults_Q) returns the result of a previously started stability operation. 

REMARK
The Wait for Completion control should only be set to Yes if the application is thoroughly tested because using this control may result in an infinite loop that blocks the calling function.

Also, if the function detects that logging is finished, the stability operation stops automatically.</Description>
            </Method>
            <Method>
               <Name>rlmfunctionstop</Name>
               <Location>ReturnLossModulesRLMDataAcquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function rlmfunctionstop(obj, RLMSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_RLM_functionStop', session, RLMSlot);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Stop RLM Function function (hp816x_RLM_functionStop) stops 
(aborts) any activated logging, stability or Min Max data acquistion operation. </Description>
            </Method>
            <Method>
               <Name>setrlmlogging</Name>
               <Location>ReturnLossModulesRLMDataAcquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [EstimatedTimeout] = setrlmlogging(obj, RLMSlot, AveragingTime, DataPoints)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
EstimatedTimeout = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_set_RLM_logging', session, RLMSlot, AveragingTime, DataPoints, EstimatedTimeout);

EstimatedTimeout = double(EstimatedTimeout.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set RLM Logging function (hp816x_set_RLM_logging) sets the parameters for a logging operation and starts the logging.</Description>
            </Method>
            <Method>
               <Name>setrlmminmax</Name>
               <Location>ReturnLossModulesRLMDataAcquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [EstimatedTime] = setrlmminmax(obj, RLMSlot, MinMaxMode, DataPoints)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
EstimatedTime = libpointer('uint32Ptr', 0);

status = calllib(libname, 'hp816x_set_RLM_minMax', session, RLMSlot, MinMaxMode, DataPoints, EstimatedTime);

EstimatedTime = double(EstimatedTime.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set RLM MinMax function (hp816x_set_RLM_minMax) sets the parameters for a MinMax logging operation.
 
A MinMax logging operation is active as long as it is not explicitly stopped. Before you start a different Return Loss module data acquisition function or different MinMax logging operation, you must call the Stop RLM Function (hp816x_RLM_functionStop) function.</Description>
            </Method>
            <Method>
               <Name>setrlmstability</Name>
               <Location>ReturnLossModulesRLMDataAcquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [EstimatedResults] = setrlmstability(obj, RLMSlot, AveragingTime, PeriodTime, TotalTime)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
EstimatedResults = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_set_RLM_stability', session, RLMSlot, AveragingTime, PeriodTime, TotalTime, EstimatedResults);

EstimatedResults = double(EstimatedResults.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set RLM Stability function (hp816x_set_RLM_stability) sets up a stability operation and starts the data acquisition.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>SwitchModules</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="SwitchModules1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>getswtroute</Name>
               <Location>SwitchModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Out] = getswtroute(obj, SWTSlot, Input)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Out = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_get_SWT_route', session, SWTSlot, Input, Out);

Out = double(Out.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function queries the current channel route of the specified switch.</Description>
            </Method>
            <Method>
               <Name>getswtroutetable</Name>
               <Location>SwitchModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [RouteTable] = getswtroutetable(obj, SWTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
RouteTable = libpointer('int8Ptr', repmat(10, 1, 512));

status = calllib(libname, 'hp816x_get_SWT_routeTable', session, SWTSlot, RouteTable);

RouteTable = strtrim(char(RouteTable.Value));

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function queries the switch configuration of the instrument. For each channel, the minimum and maximum
channel number of each port is given.</Description>
            </Method>
            <Method>
               <Name>getswttype</Name>
               <Location>SwitchModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [SwitchType, SwitchDescription] = getswttype(obj, SWTSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
SwitchType = libpointer('int32Ptr', 0);
SwitchDescription = libpointer('int8Ptr', repmat(10, 1, 512));

status = calllib(libname, 'hp816x_get_SWT_type', session, SWTSlot, SwitchType, SwitchDescription);

SwitchType = double(SwitchType.Value);
SwitchDescription = strtrim(char(SwitchDescription.Value));

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This functions returns a readable description of the switch module and a switch module type number</Description>
            </Method>
            <Method>
               <Name>setswtroute</Name>
               <Location>SwitchModules</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setswtroute(obj, SWTSlot, Input, Output)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_SWT_route', session, SWTSlot, Input, Output);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function sets the channel route between two ports.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>TunableLaserSources</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="TunableLaserSources1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>gettlsaccclass</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [AccuracyClass] = gettlsaccclass(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
AccuracyClass = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_get_TLS_accClass', session, TLSSlot, AccuracyClass);

AccuracyClass = double(AccuracyClass.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function returns the accuracy class of a backloadable TLS.</Description>
            </Method>
            <Method>
               <Name>gettlsattenuationsettingsq</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [PowerMode, Dark, Attenuation] = gettlsattenuationsettingsq(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
PowerMode = libpointer('uint16Ptr', 0);
Dark = libpointer('uint16Ptr', 0);
Attenuation = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_TLS_attenuationSettings_Q', session, TLSSlot, PowerMode, Dark, Attenuation);

PowerMode = double(PowerMode.Value);
Dark = double(Dark.Value);
Attenuation = double(Attenuation.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get TLS Attenuation Settings (hp816x_get_TLS_attenuation_Q) function returns the attenuation level, power mode and dark position of a Tunable Laser module.

NOTE:

If this function addresses a module that does not have an built-in attenuator, an error is generated.
</Description>
            </Method>
            <Method>
               <Name>gettlsautocalstate</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [AutoCalibrationState] = gettlsautocalstate(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
AutoCalibrationState = libpointer('uint16Ptr', 0);

status = calllib(libname, 'hp816x_get_TLS_autoCalState', session, TLSSlot, AutoCalibrationState);

AutoCalibrationState = double(AutoCalibrationState.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function returns the current auto calibration state.</Description>
            </Method>
            <Method>
               <Name>gettlsdarkstateq</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Dark] = gettlsdarkstateq(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Dark = libpointer('uint16Ptr', 0);

status = calllib(libname, 'hp816x_get_TLS_darkState_Q', session, TLSSlot, Dark);

Dark = double(Dark.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get TLS Dark State (hp816x_get_TLS_darkState_Q) function returns whether the optical output of your Tunable Laser module with built-in attenuation is set to the dark position.

NOTE
If this function addresses a module without a built-in attenuator, an error is generated.</Description>
            </Method>
            <Method>
               <Name>gettlslaserrisetime</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [LaserRiseTime] = gettlslaserrisetime(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
LaserRiseTime = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_TLS_laserRiseTime', session, TLSSlot, LaserRiseTime);

LaserRiseTime = double(LaserRiseTime.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get TLS Laser Rise Time (hp816x_get_TLS_laserRiseTime) function returns the laser rise time.</Description>
            </Method>
            <Method>
               <Name>gettlslaserstateq</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [LaserState] = gettlslaserstateq(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
LaserState = libpointer('uint16Ptr', 0);

status = calllib(libname, 'hp816x_get_TLS_laserState_Q', session, TLSSlot, LaserState);

LaserState = double(LaserState.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get TLS laser State (hp816x_get_TLS_laserState_Q) function returns whether the laser is turned on or off.</Description>
            </Method>
            <Method>
               <Name>gettlsopticaloutputq</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [OpticalOutput] = gettlsopticaloutputq(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
OpticalOutput = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_get_TLS_opticalOutput_Q', session, TLSSlot, OpticalOutput);

OpticalOutput = double(OpticalOutput.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get TLS Optical Output (hp816x_get_TLS_opticalOutput_Q) function returns the optical output configuration of a Tunable Laser module with two optical outputs.

REMARK

If this function addresses a module with only one optical output, an error is generated.</Description>
            </Method>
            <Method>
               <Name>gettlsparametersq</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [PowerUnit, LaserState, OpticalOutput, Power, Attenuation, Wavelength] = gettlsparametersq(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
PowerUnit = libpointer('int32Ptr', 0);
LaserState = libpointer('uint16Ptr', 0);
OpticalOutput = libpointer('int32Ptr', 0);
Power = libpointer('doublePtr', 0);
Attenuation = libpointer('doublePtr', 0);
Wavelength = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_TLS_parameters_Q', session, TLSSlot, PowerUnit, LaserState, OpticalOutput, Power, Attenuation, Wavelength);

PowerUnit = double(PowerUnit.Value);
LaserState = double(LaserState.Value);
OpticalOutput = double(OpticalOutput.Value);
Power = double(Power.Value);
Attenuation = double(Attenuation.Value);
Wavelength = double(Wavelength.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get TLS Parameters (hp816x_get_TLS_parameters_Q) function returns the most important parameters of a Tunable Laser module.</Description>
            </Method>
            <Method>
               <Name>gettlspowermaxinrangeq</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [MaximumPower] = gettlspowermaxinrangeq(obj, TLSSlot, StartofRange, EndofRange)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
MaximumPower = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_TLS_powerMaxInRange_Q', session, TLSSlot, StartofRange, EndofRange, MaximumPower);

MaximumPower = double(MaximumPower.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get TLS Max Power in Range (hp816x_get_TLS_powerMaxInRange_Q) function returns the maximum permitted power for a given wavelength interval.

This function can be used to calculate the maximum permitted power for a wavelength sweep.</Description>
            </Method>
            <Method>
               <Name>gettlspowerq</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [PowerUnit, MinimumPower, DefaultPower, MaximumPower, CurrentPower] = gettlspowerq(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
PowerUnit = libpointer('int32Ptr', 0);
MinimumPower = libpointer('doublePtr', 0);
DefaultPower = libpointer('doublePtr', 0);
MaximumPower = libpointer('doublePtr', 0);
CurrentPower = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_TLS_power_Q', session, TLSSlot, PowerUnit, MinimumPower, DefaultPower, MaximumPower, CurrentPower);

PowerUnit = double(PowerUnit.Value);
MinimumPower = double(MinimumPower.Value);
DefaultPower = double(DefaultPower.Value);
MaximumPower = double(MaximumPower.Value);
CurrentPower = double(CurrentPower.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get TLS Power (hp816x_get_TLS_power_Q) function returns the current values of the following: the Power Units, Minimum Power, Maximum Power, Default Power, and Current Power. The power limits depend on the current optical output.
</Description>
            </Method>
            <Method>
               <Name>gettlstemperatures</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [ActualTemperature, TemperatureDifference, TemperatureLastZero] = gettlstemperatures(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
ActualTemperature = libpointer('doublePtr', 0);
TemperatureDifference = libpointer('doublePtr', 0);
TemperatureLastZero = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_TLS_temperatures', session, ActualTemperature, TemperatureDifference, TemperatureLastZero);

ActualTemperature = double(ActualTemperature.Value);
TemperatureDifference = double(TemperatureDifference.Value);
TemperatureLastZero = double(TemperatureLastZero.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get TLS Temperatures (hp816x_get_temperatues) function returns temperatures related to the auto zeroing of backloadable tuneable laser sources.</Description>
            </Method>
            <Method>
               <Name>gettlstemperaturesex</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [ActualTemperature, TemperatureDifference, TemperatureLastZero] = gettlstemperaturesex(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
ActualTemperature = libpointer('doublePtr', 0);
TemperatureDifference = libpointer('doublePtr', 0);
TemperatureLastZero = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_TLS_temperaturesEx', session, TLSSlot, ActualTemperature, TemperatureDifference, TemperatureLastZero);

ActualTemperature = double(ActualTemperature.Value);
TemperatureDifference = double(TemperatureDifference.Value);
TemperatureLastZero = double(TemperatureLastZero.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get TLS Temperatures Ex (hp816x_get_temperatuesEx) function returns temperatures related to the auto zeroing of tuneable laser sources.</Description>
            </Method>
            <Method>
               <Name>gettlstriggerconfiguration</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [TriggerIn, TriggerOut] = gettlstriggerconfiguration(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
TriggerIn = libpointer('int32Ptr', 0);
TriggerOut = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_get_TLS_triggerConfiguration', session, TLSSlot, TriggerIn, TriggerOut);

TriggerIn = double(TriggerIn.Value);
TriggerOut = double(TriggerOut.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get TLS Trigger Configuration (hp816x_get_TLS_triggerConfiguration) function returns:

- the selected Tunable Laser module's input triggers configuration and

- the selected Tunable Laser module's output triggers configuration.</Description>
            </Method>
            <Method>
               <Name>gettlswavelengthq</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [MinimumWavelength, DefaultWavelength, MaximumWavelength, CurrentWavelength] = gettlswavelengthq(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
MinimumWavelength = libpointer('doublePtr', 0);
DefaultWavelength = libpointer('doublePtr', 0);
MaximumWavelength = libpointer('doublePtr', 0);
CurrentWavelength = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_TLS_wavelength_Q', session, TLSSlot, MinimumWavelength, DefaultWavelength, MaximumWavelength, CurrentWavelength);

MinimumWavelength = double(MinimumWavelength.Value);
DefaultWavelength = double(DefaultWavelength.Value);
MaximumWavelength = double(MaximumWavelength.Value);
CurrentWavelength = double(CurrentWavelength.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get TLS Wavelength (hp816x_get_TLS_wavelenght_Q) function returns the current values of the following: Minimum Wavelength, Maximum Wavelength, Default Wavelength, and Current Wavelength.</Description>
            </Method>
            <Method>
               <Name>settlsattenuation</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function settlsattenuation(obj, TLSSlot, PowerMode, DarkenLaser, Attenuation)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_TLS_attenuation', session, TLSSlot, PowerMode, DarkenLaser, Attenuation);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set TLS Attenuation (hp816x_set_TLS_attenuation) function adjusts the attenuation of a Tunable Laser module. 

NOTE
If this function addresses a module without a built-in attenuator, an error is generated.</Description>
            </Method>
            <Method>
               <Name>settlsautocalibration</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function settlsautocalibration(obj, TLSSlot, Autocalibration)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_TLS_autoCalibration', session, TLSSlot, Autocalibration);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function turns the auto calibration ON (OFF). </Description>
            </Method>
            <Method>
               <Name>settlsdark</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function settlsdark(obj, TLSSlot, DarkenLaser)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_TLS_dark', session, TLSSlot, DarkenLaser);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set TLS Dark (hp816x_set_TLS_dark) function sets the attenuation of your Tunable Laser module with built-in attenuation to the dark position.

No light is emitted from the optical output if the TLS is set to the dark position.

Use this function to turn the laser on or off without any settling delays.

NOTE
If this function addresses a module without a built-in attenuator, an error is generated.</Description>
            </Method>
            <Method>
               <Name>settlslaserrisetime</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function settlslaserrisetime(obj, TLSSlot, LaserRiseTime)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_TLS_laserRiseTime', session, TLSSlot, LaserRiseTime);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set TLS Laser Rise Time (hp816x_set_TLS_laserRiseTime) function adjusts the laser rise time.</Description>
            </Method>
            <Method>
               <Name>settlslaserstate</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function settlslaserstate(obj, TLSSlot, LaserState)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_TLS_laserState', session, TLSSlot, LaserState);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set TLS Laser State (hp816x_set_TLS_laserState) function turns the laser on or off.</Description>
            </Method>
            <Method>
               <Name>settlsopticaloutput</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function settlsopticaloutput(obj, TLSSlot, SetOpticalOutput)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_TLS_opticalOutput', session, TLSSlot, SetOpticalOutput);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set TLS Optical Output (hp816x_set_TLS_opticalOutput) function configures the optical output of Tunable Laser module with two optical outputs.</Description>
            </Method>
            <Method>
               <Name>settlsparameters</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function settlsparameters(obj, TLSSlot, PowerUnit, OpticalOutput, TurnLaser, Power, Attenuation, Wavelength)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_TLS_parameters', session, TLSSlot, PowerUnit, OpticalOutput, TurnLaser, Power, Attenuation, Wavelength);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set TLS Parameters (hp816x_set_TLS_parameters) function sets the most important parameters of a Tunable Laser module.</Description>
            </Method>
            <Method>
               <Name>settlspower</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function settlspower(obj, TLSSlot, Unit, PowerSelection, ManualPower)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_TLS_power', session, TLSSlot, Unit, PowerSelection, ManualPower);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set TLS Power (hp816x_set_TLS_power) function sets the power of a Tunable Laser module.

REMARK
If you choose Manual Input as the Power Selection input, you can use the Manual Power input to set the power to a value in dBm or Watts, depending on how you set the Unit control.
</Description>
            </Method>
            <Method>
               <Name>settlstriggerconfiguration</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function settlstriggerconfiguration(obj, TLSSlot, TriggerIn, TriggerOut)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_TLS_triggerConfiguration', session, TLSSlot, TriggerIn, TriggerOut);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set TLS Trigger Configuration (hp816x_set_TLS_triggerConfiguration) function configures:

- how the Tunable Laser module processes input triggers, and

- how an output trigger is generated.</Description>
            </Method>
            <Method>
               <Name>settlswavelength</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function settlswavelength(obj, TLSSlot, WavelengthSelection, Wavelength)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_TLS_wavelength', session, TLSSlot, WavelengthSelection, Wavelength);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set TLS Wavelength (hp816x_set_TLS_wavelength) function sets the wavelength of a Tunable Laser module.</Description>
            </Method>
            <Method>
               <Name>tlszeroing</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function tlszeroing(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_TLS_zeroing', session);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The TLS Zeroing (hp816x_TLS_zeroing) function starts a lambda zeroing operation for a back-loadable Tunable Laser module.</Description>
            </Method>
            <Method>
               <Name>tlszeroingall</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function tlszeroingall(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_TLS_zeroingAll', session);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The TLS Zeroing (hp816x_TLS_zeroingAll) function starts lambda zeroing operations on all back-loadable, 8196x and 8194x Tunable Laser modules within a 816x mainframe.</Description>
            </Method>
            <Method>
               <Name>tlszeroingex</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function tlszeroingex(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_TLS_zeroingEx', session, TLSSlot);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The TLS Zeroing Ex (hp816x_TLS_zeroingEx) function starts a lambda zeroing operation for a Tunable Laser module.</Description>
            </Method>
            <Method>
               <Name>waitforopc</Name>
               <Location>TunableLaserSources</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function waitforopc(obj, TLSSlot, WaitforOperationComplete)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_WaitForOPC', session, TLSSlot, WaitforOperationComplete);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>Use this function, if DFB Laser Sources are installed. Because changeing the wavelength of DFB sources is a time consuming operation, this function may be used to return immediatly from a wavelength setting operation. </Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>TunableLaserSourcesTLSFrequencyOffset</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="TunableLaserSourcesTLSFrequencyOffset1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>displaytolambdazero</Name>
               <Location>TunableLaserSourcesTLSFrequencyOffset</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function displaytolambdazero(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_displayToLambdaZero', session, TLSSlot);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The TLS Display to Lambda Zero function (hp816x_get_TLS_lambdaZero_Q) transfers the actual displayed wavelength to Lambda0, the base wavelength for calculating the frequency offset.

See your instrument's User's Guide for more information on the frequency offset.</Description>
            </Method>
            <Method>
               <Name>gettlsfrequencyoffsetq</Name>
               <Location>TunableLaserSourcesTLSFrequencyOffset</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Offset] = gettlsfrequencyoffsetq(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Offset = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_TLS_frequencyOffset_Q', session, TLSSlot, Offset);

Offset = double(Offset.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get TLS Frequency Offset function (hp816x_get_TLS_frequencyOffset_Q) function returns the frequency offset in Hertz (Hz).

See your instrument's User's Guide for more information on the frequency offset.</Description>
            </Method>
            <Method>
               <Name>gettlslambdazeroq</Name>
               <Location>TunableLaserSourcesTLSFrequencyOffset</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Lambda0] = gettlslambdazeroq(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Lambda0 = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_TLS_lambdaZero_Q', session, TLSSlot, Lambda0);

Lambda0 = double(Lambda0.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get Lambda Zero function (hp816x_get_TLS_lambdaZero_Q) returns the base wavelength (Lambda0) of a Tunable Laser module.

See your instrument's User's Guide for more information on the frequency offset.</Description>
            </Method>
            <Method>
               <Name>settlsfrequencyoffset</Name>
               <Location>TunableLaserSourcesTLSFrequencyOffset</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function settlsfrequencyoffset(obj, TLSSlot, Offset)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_TLS_frequencyOffset', session, TLSSlot, Offset);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set TLS Frequency Offset function (hp816x_set_TLS_frequencyOffset) sets the reference wavelength in Hertz (Hz).

See your instrument's User's Guide for more information on the frequency offset.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>TunableLaserSourcesTLSLogging</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="TunableLaserSourcesTLSLogging1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>Get_TLS_lambdaLoggingState</Name>
               <Location>TunableLaserSourcesTLSLogging</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

[status, propertyValue] = calllib(libname, 'hp816x_get_TLS_lambdaLoggingState_Q', session, 0);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while getting the property value.\n%s', errorMessage)
end
propertyValue = double(propertyValue);</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Boolean</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>Get_TLS_wavelengthPoints</Name>
               <Location>TunableLaserSourcesTLSLogging</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

[status, propertyValue] = calllib(libname, 'hp816x_get_TLS_wavelengthPoints_Q', session, 0);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while getting the property value.\n%s', errorMessage)
end
propertyValue = double(propertyValue);</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>gettlslambdaloggingstateexq</Name>
               <Location>TunableLaserSourcesTLSLogging</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [LambdaLoggingState] = gettlslambdaloggingstateexq(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
LambdaLoggingState = libpointer('uint16Ptr', 0);

status = calllib(libname, 'hp816x_get_TLS_lambdaLoggingStateEx_Q', session, TLSSlot, LambdaLoggingState);

LambdaLoggingState = double(LambdaLoggingState.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get TLS Lambda Logging State Ex (hp816x_get_TLS_lambdaLoggingStateEx) function returns whether Lambda Logging  is turned On or Off.

Lambda Logging is a feature that records the exact wavelength of a Tunable Laser module when a trigger is generated during a continuous sweep.

You can use this function to determine when a Lambda Logging operation is completed. This is useful because the Get Number of Wavelength Values Ex (hp816x_get_TLS_wavelengthPointsEx_Q) function and the Get Logged Wavelength Data Ex (hp816x_get_TLS_wavelengthDataEx_Q) function return meaningless values unless the Lambda Logging operation is completed.</Description>
            </Method>
            <Method>
               <Name>gettlswavelengthdataexq</Name>
               <Location>TunableLaserSourcesTLSLogging</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [WavelengthData] = gettlswavelengthdataexq(obj, TLSSlot, ArraySize, WavelengthData)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
WavelengthData = libpointer('doublePtr', WavelengthData);

status = calllib(libname, 'hp816x_get_TLS_wavelengthDataEx_Q', session, TLSSlot, ArraySize, WavelengthData);

WavelengthData = double(WavelengthData.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get Logged Wavelength Data Ex (hp816x_get_TLS_wavelengthDataEx_Q) function returns the results of a Lambda Logging operation. 

If you call this function before the Lambda Logging operation completes, the returned value is meaningless. Use the Get Lambda Logging State function (hp816x_get_TLS_lambdaLoggingStateEx_Q) to confirm that the Lambda Logging operation is completed.</Description>
            </Method>
            <Method>
               <Name>gettlswavelengthdataq</Name>
               <Location>TunableLaserSourcesTLSLogging</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [WavelengthData] = gettlswavelengthdataq(obj, ArraySize, WavelengthData)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
WavelengthData = libpointer('doublePtr', WavelengthData);

status = calllib(libname, 'hp816x_get_TLS_wavelengthData_Q', session, ArraySize, WavelengthData);

WavelengthData = double(WavelengthData.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get Logged Wavelength Data (hp816x_get_TLS_wavelengthData_Q) function returns the results of a Lambda Logging operation. 

If you call this function before the Lambda Logging operation completes, the returned value is meaningless. Use the Get Lambda Logging State function (hp816x_get_TLS_lambdaLoggingState_Q) to confirm that the Lambda Logging operation is completed.</Description>
            </Method>
            <Method>
               <Name>gettlswavelengthpointsexq</Name>
               <Location>TunableLaserSourcesTLSLogging</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [NumberofWavelengthValues] = gettlswavelengthpointsexq(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
NumberofWavelengthValues = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_get_TLS_wavelengthPointsEx_Q', session, TLSSlot, NumberofWavelengthValues);

NumberofWavelengthValues = double(NumberofWavelengthValues.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get Number of Wavelength Values Ex (hp816x_get_TLS_wavelengthPointsEx_Q) function returns the number of wavelength points that will be used in a Lambda Logging operation.</Description>
            </Method>
            <Method>
               <Name>settlslambdaloggingstate</Name>
               <Location>TunableLaserSourcesTLSLogging</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function settlslambdaloggingstate(obj, LambdaLoggingState)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_TLS_lambdaLoggingState', session, LambdaLoggingState);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set TLS Lambda Logging State (hp816x_set_TLS_lambdaLoggingState) function turns Lambda Logging On or Off.

Lambda Logging is a feature that records the exact wavelength of a Tunable Laser module when a trigger is generated during a continuous sweep. 

Lambda Logging is disabled at the end of a sweep. If you want to start a new wavelength sweep with Lambda Logging activated, you must be reset Lambda Logging to On. 

NOTE: Lambda Logging is not available if your Tunable Laser module firmware revision is lower than 2.0.

NOTE: After this function completes, Trigger Out mode
of the Set TLS Trigger Configuration (hp816x_set_TLS_triggerConfiguration) function will be set to Step Finished (hp816x_TRIGOUT_STEP_FINISHED). Call the Set TLS Trigger Configuration (hp816x_set_TLS_triggerConfiguration) function to readjust the Trigger Out mode. </Description>
            </Method>
            <Method>
               <Name>settlslambdaloggingstateex</Name>
               <Location>TunableLaserSourcesTLSLogging</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function settlslambdaloggingstateex(obj, TLSSlot, LambdaLoggingState)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_TLS_lambdaLoggingStateEx', session, TLSSlot, LambdaLoggingState);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set TLS Lambda Logging State Ex (hp816x_set_TLS_lambdaLoggingStateEx) function turns Lambda Logging On or Off.

Lambda Logging is a feature that records the exact wavelength of a Tunable Laser module when a trigger is generated during a continuous sweep. 

Lambda Logging is disabled at the end of a sweep. If you want to start a new wavelength sweep with Lambda Logging activated, you must be reset Lambda Logging to On. 

NOTE: Lambda Logging is not available if your Tunable Laser module firmware revision is lower than 2.0.

NOTE: After this function completes, Trigger Out mode
of the Set TLS Trigger Configuration (hp816x_set_TLS_triggerConfiguration) function will be set to Step Finished (hp816x_TRIGOUT_STEP_FINISHED). Call the Set TLS Trigger Configuration (hp816x_set_TLS_triggerConfiguration) function to readjust the Trigger Out mode. </Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>TunableLaserSourcesTLSMaximumPowerCurve</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="TunableLaserSourcesTLSMaximumPowerCurve1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>gettlspowerdataq</Name>
               <Location>TunableLaserSourcesTLSMaximumPowerCurve</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [WavelengthData, PowerData] = gettlspowerdataq(obj, TLSSlot, NumberofDataItems, WavelengthData, PowerData)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
WavelengthData = libpointer('doublePtr', WavelengthData);
PowerData = libpointer('doublePtr', PowerData);

status = calllib(libname, 'hp816x_get_TLS_powerData_Q', session, TLSSlot, NumberofDataItems, WavelengthData, PowerData);

WavelengthData = double(WavelengthData.Value);
PowerData = double(PowerData.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get Logged Power Data (hp816x_get_TLS_power_data_Q) function returns two arrays, the first array returns wavelength values and the second array returns corresponding power values. 

The position of each wavelength and power value in each array corresponds to describe the maximum power available at the corresponding wavelength. In this way the two arrays describe the maximum power curve for the Tunable Laser module.</Description>
            </Method>
            <Method>
               <Name>gettlspowerpointsq</Name>
               <Location>TunableLaserSourcesTLSMaximumPowerCurve</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [NumberofPowerPoints] = gettlspowerpointsq(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
NumberofPowerPoints = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_get_TLS_powerPoints_Q', session, TLSSlot, NumberofPowerPoints);

NumberofPowerPoints = double(NumberofPowerPoints.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get Number of Power Points (hp816x_get_TLS_powerPoints_Q) function returns the maximum number of data items (wavelength, power) which will be returned from the Get Logged Power Data (hp816x_get_TLS_power_data_Q) function.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>TunableLaserSourcesTLSModulation</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="TunableLaserSourcesTLSModulation1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>gettlsbncconfigq</Name>
               <Location>TunableLaserSourcesTLSModulation</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [BNCOutput] = gettlsbncconfigq(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
BNCOutput = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_get_TLS_BNC_config_Q', session, TLSSlot, BNCOutput);

BNCOutput = double(BNCOutput.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get TLS BNC Configuration (hp816x_get_TLS_BNC_config_Q) function returns the configuration of the BNC output connector on the front panel of some Tunable Laser modules.</Description>
            </Method>
            <Method>
               <Name>gettlscclevelq</Name>
               <Location>TunableLaserSourcesTLSModulation</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [CCLevel] = gettlscclevelq(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
CCLevel = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_TLS_ccLevel_Q', session, TLSSlot, CCLevel);

CCLevel = double(CCLevel.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>gettlsmodulationsettingsq</Name>
               <Location>TunableLaserSourcesTLSModulation</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [ModulationSource, ModulationOutput, ModulationState, Frequency] = gettlsmodulationsettingsq(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
ModulationSource = libpointer('int32Ptr', 0);
ModulationOutput = libpointer('uint16Ptr', 0);
ModulationState = libpointer('uint16Ptr', 0);
Frequency = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_TLS_modulationSettings_Q', session, TLSSlot, ModulationSource, ModulationOutput, ModulationState, Frequency);

ModulationSource = double(ModulationSource.Value);
ModulationOutput = double(ModulationOutput.Value);
ModulationState = double(ModulationState.Value);
Frequency = double(Frequency.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get TLS Modulation Setting (hp816x_get_TLS_modulationSettings_Q) function returns the current modulation setting of a Tunable Laser module.
</Description>
            </Method>
            <Method>
               <Name>settlscclevel</Name>
               <Location>TunableLaserSourcesTLSModulation</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function settlscclevel(obj, TLSSlot, CCLevel)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_TLS_ccLevel', session, TLSSlot, CCLevel);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>This function sets the coherence control level (1-99.98%) of a DFB laser source.</Description>
            </Method>
            <Method>
               <Name>settlsmodulation</Name>
               <Location>TunableLaserSourcesTLSModulation</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function settlsmodulation(obj, TLSSlot, ModulationSource, ModulationOutput, Modulation, ModulationFrequency)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_TLS_modulation', session, TLSSlot, ModulationSource, ModulationOutput, Modulation, ModulationFrequency);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set TLS Modulation (hp816x_setup_TLS_modulation) function sets the modulation of your Tunable Laser module.</Description>
            </Method>
            <Method>
               <Name>tlsconfigurebnc</Name>
               <Location>TunableLaserSourcesTLSModulation</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function tlsconfigurebnc(obj, TLSSlot, BNCOutput)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_TLS_configureBNC', session, TLSSlot, BNCOutput);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The TLS Configure BNC Output (hp816x_TLS_configureBNC) function configures the BNC output connector on the front panel of some Tunable Laser modules.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>TunableLaserSourcesTLSSBSSuppressionSBS</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="TunableLaserSourcesTLSSBSSuppressionSBS1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>gettlssbscontrolq</Name>
               <Location>TunableLaserSourcesTLSSBSSuppressionSBS</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [FMState, Frequency] = gettlssbscontrolq(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
FMState = libpointer('uint16Ptr', 0);
Frequency = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_TLS_SBS_control_q', session, TLSSlot, FMState, Frequency);

FMState = double(FMState.Value);
Frequency = double(Frequency.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get TLS SBS Control (hp816x_get_TLS_SBS_control_q) function return the current state of the Stimulated Brillouin Scattering (SBS) suppression feature.</Description>
            </Method>
            <Method>
               <Name>gettlssbslevelq</Name>
               <Location>TunableLaserSourcesTLSSBSSuppressionSBS</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [SBSLevel] = gettlssbslevelq(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
SBSLevel = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_get_TLS_SBSLevel_Q', session, TLSSlot, SBSLevel);

SBSLevel = double(SBSLevel.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get SBS Suppression Level (hp816x_get_TLS_SBSLevel_Q) function returns the current SBS suppression level in percent of a Tunable Laser module.</Description>
            </Method>
            <Method>
               <Name>settlssbscontrol</Name>
               <Location>TunableLaserSourcesTLSSBSSuppressionSBS</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function settlssbscontrol(obj, TLSSlot, FMState, FMFrequency)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_TLS_SBS_control', session, TLSSlot, FMState, FMFrequency);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set TLS SBS Control (hp816x_set_TLS_SBS_control) function enables or disables the Stimulated Brillouin Scattering (SBS) suppression feature.</Description>
            </Method>
            <Method>
               <Name>settlssbslevel</Name>
               <Location>TunableLaserSourcesTLSSBSSuppressionSBS</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function settlssbslevel(obj, TLSSlot, SBSLevel)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_TLS_SBSLevel', session, TLSSlot, SBSLevel);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set SBS Suppression Level (hp816x_set_TLS_SBSLevel) function sets the SBS suppression level (1-99.98%) of a tunable laser source.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>TunableLaserSourcesTLSSweep</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="TunableLaserSourcesTLSSweep1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>gettlssweepstateq</Name>
               <Location>TunableLaserSourcesTLSSweep</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [SweepState] = gettlssweepstateq(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
SweepState = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_get_TLS_sweepState_Q', session, TLSSlot, SweepState);

SweepState = double(SweepState.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get TLS Sweep State (hp816x_get_TLS_sweepState_Q) function returns the current state of a sweep.</Description>
            </Method>
            <Method>
               <Name>settlssweep</Name>
               <Location>TunableLaserSourcesTLSSweep</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function settlssweep(obj, TLSSlot, SweepMode, RepeatMode, Cycles, DwellTime, StartWavelength, StopWavelength, StepSize, SweepSpeed)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_set_TLS_sweep', session, TLSSlot, SweepMode, RepeatMode, Cycles, DwellTime, StartWavelength, StopWavelength, StepSize, SweepSpeed);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set TLS Sweep (hp816x_set_TLS_Sweep) function sets up a sweep operation for a Tunable Laser module.</Description>
            </Method>
            <Method>
               <Name>tlssweepcontrol</Name>
               <Location>TunableLaserSourcesTLSSweep</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function tlssweepcontrol(obj, TLSSlot, Action)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_TLS_sweepControl', session, TLSSlot, Action);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The TLS Sweep Control (hp816x_TLS_sweepControl) function controls a wavelength sweep operation.</Description>
            </Method>
            <Method>
               <Name>tlssweepnextstep</Name>
               <Location>TunableLaserSourcesTLSSweep</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function tlssweepnextstep(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_TLS_sweepNextStep', session, TLSSlot);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The TLS Next Step (hp816x_TLS_sweepNextStep) function sweeps one step forward.</Description>
            </Method>
            <Method>
               <Name>tlssweeppreviousstep</Name>
               <Location>TunableLaserSourcesTLSSweep</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function tlssweeppreviousstep(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_TLS_sweepPreviousStep', session, TLSSlot);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The TLS Previous Step (hp816x_TLS_sweepPreviousStep) function sweeps one step backward.</Description>
            </Method>
            <Method>
               <Name>tlssweepwait</Name>
               <Location>TunableLaserSourcesTLSSweep</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function tlssweepwait(obj, TLSSlot)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_TLS_sweepWait', session, TLSSlot);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Wait Sweep Finished (hp816x_TLS_sweepWait) function forces the program to wait until the sweep finishes. </Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>Utility</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="Utility1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>UtilityTimeOut</Name>
               <Location>Utility</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

[status, propertyValue] = calllib(libname, 'hp816x_timeOut_Q', session, 0);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while getting the property value.\n%s', errorMessage)
end
propertyValue = double(propertyValue);</GetMCode>
                  <SetMCode>function setProperty(obj, propertyName, propertyValue)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_timeOut', session, propertyValue);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while setting the property value.\n%s', errorMessage)
end
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>cls</Name>
               <Location>Utility</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function cls(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_cls', session);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Clear Error Queue function (hp816x_cls) clears the instrument's error queue. This function performs the same function as the GPIB command, "*CLS".

See your instrument's Programming Guide for more information.</Description>
            </Method>
            <Method>
               <Name>dbmtowatt</Name>
               <Location>Utility</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Watt] = dbmtowatt(obj, dBm)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Watt = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_dbmToWatt', session, dBm, Watt);

Watt = double(Watt.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The dBm to Watt function (hp816x_dbmToWatt) converts a power value in dBm into Watts. </Description>
            </Method>
            <Method>
               <Name>dcl</Name>
               <Location>Utility</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function dcl(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_dcl', session);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Device Clear function (hp816x_dcl) clears the following:

1. The Instrument Error Queue

2. The Standard Event Status Register

3. The Status Byte

See the your instrument's Programming Guide for further information. This function performs the same purpose as the *CLS GPIB command.</Description>
            </Method>
            <Method>
               <Name>driverlogg</Name>
               <Location>Utility</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function driverlogg(obj, Filename, Logging, IncludeReplies)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Filename = [double(Filename) 0];

status = calllib(libname, 'hp816x_driverLogg', session, Filename, Logging, IncludeReplies);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Enable Driver Logging function (hp816x_driverLogg) logs all commands sent to the instrument to a file in text format, with the exception of data aquisition commands.

If the file exists, the output will be appended.

This log file can become very large, especially if the instrument is polled for some reason.</Description>
            </Method>
            <Method>
               <Name>errormessage</Name>
               <Location>Utility</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [ErrorMessage] = errormessage(obj, ErrorCode)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
ErrorMessage = libpointer('int8Ptr', repmat(10, 1, 512));

status = calllib(libname, 'hp816x_error_message', session, ErrorCode, ErrorMessage);

ErrorMessage = strtrim(char(ErrorMessage.Value));

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Error Message function (hp816x_error_message) transforms the error code returned from any instrument driver to a user-readable string.

Connect the Status output of any function to the Error Code input of this function to get information about any instrument or driver errors.</Description>
            </Method>
            <Method>
               <Name>errorquery</Name>
               <Location>Utility</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [InstrumentErrorCode, ErrorMessage] = errorquery(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
InstrumentErrorCode = libpointer('int32Ptr', 0);
ErrorMessage = libpointer('int8Ptr', repmat(10, 1, 512));

status = calllib(libname, 'hp816x_error_query', session, InstrumentErrorCode, ErrorMessage);

InstrumentErrorCode = double(InstrumentErrorCode.Value);
ErrorMessage = strtrim(char(ErrorMessage.Value));

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Instrument Error Query function (hp816x_error_query) returns the error number and corresponding error message from the error queue of the instrument. This type of error is caused by the instrument or one of the installed modules.

See your instrument's Programming Guide for a listing of the instrument error numbers and messages.

Instrument errors can occur because you have placed the instrument in a bad state. For example, if you send an invalid sequence of coupled commands.

Automatic error detection can be accomplished by using the Automatic Error Detection function (hp816x_errorQueryDetect).
</Description>
            </Method>
            <Method>
               <Name>errorquerydetect</Name>
               <Location>Utility</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function errorquerydetect(obj, AutomaticErrorDetection)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_errorQueryDetect', session, AutomaticErrorDetection);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Automatic Error Detection function (hp816x_errorQueryDetect) checks for instrument errors. 

After each command the Error Status Register is read and checked for errors. 

If you want to increase execution speed, it is recommended to turn Automatic Error Dectection OFF. After an application is tested, instrument errors are less likely.</Description>
            </Method>
            <Method>
               <Name>forcetransaction</Name>
               <Location>Utility</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function forcetransaction(obj, ForceTransaction)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_forceTransaction', session, ForceTransaction);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Force Transaction function (hp816x_forceTransaction) enables you to increase execution speed.

If Force Transaction is turned Off, a command is only transmitted to the instrument, if a difference between an actual parameter and a previous setting is noticed. 

If Force Transaction is turned On, each parameter setting is transmitted to the instrument, independent of previous settings. 

Turning the Force Transaction function Off causes the driver to run faster. 

REMARKS
The default value is ON. 
If Force Transactions is turned Off, manual adjustments are not noticed by the driver and can falsify results.</Description>
            </Method>
            <Method>
               <Name>getdate</Name>
               <Location>Utility</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Year, Month, Day] = getdate(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Year = libpointer('int32Ptr', 0);
Month = libpointer('int32Ptr', 0);
Day = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_getDate', session, Year, Month, Day);

Year = double(Year.Value);
Month = double(Month.Value);
Day = double(Day.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get Date function (hp816x_getDate) returns the current date of the instrument.</Description>
            </Method>
            <Method>
               <Name>getinstrumentidq</Name>
               <Location>Utility</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [IDNString] = getinstrumentidq(obj, BusAddress)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
BusAddress = [double(BusAddress) 0];
IDNString = libpointer('int8Ptr', repmat(10, 1, 512));

status = calllib(libname, 'hp816x_getInstrumentId_Q', BusAddress, IDNString);

IDNString = strtrim(char(IDNString.Value));

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get Instrument ID function (hp816x_getInstrumentId_Q) returns the IDN string of an instrument.

For example, the IDN string might include the instrument's manufacturer, model, serial number, and firmware revision..</Description>
            </Method>
            <Method>
               <Name>gettime</Name>
               <Location>Utility</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Hour, Minute, Second] = gettime(obj)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
Hour = libpointer('int32Ptr', 0);
Minute = libpointer('int32Ptr', 0);
Second = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_getTime', session, Hour, Minute, Second);

Hour = double(Hour.Value);
Minute = double(Minute.Value);
Second = double(Second.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Get Time function (hp816x_getTime) returns the current time of the instrument.</Description>
            </Method>
            <Method>
               <Name>listvisaq</Name>
               <Location>Utility</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [NumberOfDevices, ListofAddresses] = listvisaq(obj, Interface, Select)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
NumberOfDevices = libpointer('int32Ptr', 0);
ListofAddresses = libpointer('int8Ptr', repmat(10, 1, 512));

status = calllib(libname, 'hp816x_listVisa_Q', Interface, Select, NumberOfDevices, ListofAddresses);

NumberOfDevices = double(NumberOfDevices.Value);
ListofAddresses = strtrim(char(ListofAddresses.Value));

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The List Visa Addresses (hp816x_listVisa_Q) function returns a comma separated list of VISA interface addresses. 

You can use these addresses to initialize the hp816x VXIplug&amp;play Instrument Driver.</Description>
            </Method>
            <Method>
               <Name>setbaudrate</Name>
               <Location>Utility</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setbaudrate(obj, InterfaceIdentifier, Baudrate)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
InterfaceIdentifier = [double(InterfaceIdentifier) 0];

status = calllib(libname, 'hp816x_setBaudrate', InterfaceIdentifier, Baudrate);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set Baudrate function (hp816x_setBaudrate) sets the baudrate of the instrument serial port. 

Remark: This function does not needs an instrument handle because getting a handle implies an init call, which requires communication to be running. This function cannot be used with Agilent Vee.</Description>
            </Method>
            <Method>
               <Name>setdate</Name>
               <Location>Utility</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function setdate(obj, Year, Month, Day)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_setDate', session, Year, Month, Day);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set Date function (hp816x_setDate) sets the current date of the instrument.</Description>
            </Method>
            <Method>
               <Name>settime</Name>
               <Location>Utility</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function settime(obj, Hour, Minute, Second)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');

status = calllib(libname, 'hp816x_setTime', session, Hour, Minute, Second);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Set Time function (hp816x_setTime) sets the current time of the instrument.</Description>
            </Method>
            <Method>
               <Name>watttodbm</Name>
               <Location>Utility</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [dBm] = watttodbm(obj, Watt)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
dBm = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_WattToDBm', session, Watt, dBm);

dBm = double(dBm.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Watt to dBm function (hp816x_WattToDBm) converts a power value in Watts into dBm. </Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>UtilityPassThrough</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="UtilityPassThrough1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>cmd</Name>
               <Location>UtilityPassThrough</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function cmd(obj, CommandString)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
CommandString = [double(CommandString) 0];

status = calllib(libname, 'hp816x_cmd', session, CommandString);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Send String Command function (hp816x_cmd) sends a GPIB command (conforming to the SCPI standard) to the instrument. It does not look for a response.

See your instrument's Programming Guide for information on GPIB commands.</Description>
            </Method>
            <Method>
               <Name>cmdint</Name>
               <Location>UtilityPassThrough</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function cmdint(obj, IntegerCommand, IntegerValue)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
IntegerCommand = [double(IntegerCommand) 0];

status = calllib(libname, 'hp816x_cmdInt', session, IntegerCommand, IntegerValue);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Send Integer Command function (hp816x_cmdInt) sends an instrument command which requires one integer parameter.      

See your instrument's Programming Guide for information on GPIB commands.
</Description>
            </Method>
            <Method>
               <Name>cmdint32q</Name>
               <Location>UtilityPassThrough</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [IntegerResult] = cmdint32q(obj, IntegerQuery)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
IntegerQuery = [double(IntegerQuery) 0];
IntegerResult = libpointer('int32Ptr', 0);

status = calllib(libname, 'hp816x_cmdInt32_Q', session, IntegerQuery, IntegerResult);

IntegerResult = double(IntegerResult.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Send Integer Query function (hp816x_cmdInt32_Q) sends a GPIB query string to the instrument and waits for a response that must be representable as a ViInt32. A non-numeric instrument response returns zero as the result.

See your instrument's Programming Guide for information on GPIB commands.
</Description>
            </Method>
            <Method>
               <Name>cmdreal</Name>
               <Location>UtilityPassThrough</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function cmdreal(obj, RealCommand, RealValue)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
RealCommand = [double(RealCommand) 0];

status = calllib(libname, 'hp816x_cmdReal', session, RealCommand, RealValue);


if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Send Real Command function (hp816x_cmdReal) sends an instrument command which requires one real parameter.

See your instrument's Programming Guide for information on GPIB commands.
</Description>
            </Method>
            <Method>
               <Name>cmdreal64q</Name>
               <Location>UtilityPassThrough</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [RealResult] = cmdreal64q(obj, RealQuery)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
RealQuery = [double(RealQuery) 0];
RealResult = libpointer('doublePtr', 0);

status = calllib(libname, 'hp816x_cmdReal64_Q', session, RealQuery, RealResult);

RealResult = double(RealResult.Value);

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Send Real Query function (hp816x_cmdReal64_Q) sends a GPIB query string to the instrument and waits for a response that must be representable as a ViReal64. 

See your instrument's Programming Guide for information on GPIB commands.</Description>
            </Method>
            <Method>
               <Name>cmdstringq</Name>
               <Location>UtilityPassThrough</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Result] = cmdstringq(obj, InputQuery, StringSize)

libname = get(get(obj, 'Parent'), 'DriverName');
session = get(get(obj, 'Parent'), 'Interface');
InputQuery = [double(InputQuery) 0];
Result = libpointer('int8Ptr', repmat(10, 1, 512));

status = calllib(libname, 'hp816x_cmdString_Q', session, InputQuery, StringSize, Result);

Result = strtrim(char(Result.Value));

if (status &lt; 0)
	errorMessage = libpointer('int8Ptr', repmat(10, 1, 512));
	status = calllib(libname, 'hp816x_error_message', session, status, errorMessage);

	if (status &lt; 0)
		error('Failed to interpret error message');
	end

	errorMessage = strtrim(char(errorMessage.Value));
	error('The instrument returned an error while executing the function.\n%s', errorMessage)
end
</MCode>
               </Code>
               <Description>The Send String Query function (hp816x_cmdString_Q) sends a GPIB query string to the instrument and waits for a response which must be a string (character data).

A minimum of one byte will be read from the instrument and the string will be NULL terminated (so its length can be found with strlen, the String Length C function).
</Description>
            </Method>
         </MethodInfo>
      </Group>
   </GroupInfo>
</MATLABInstrumentDriver>